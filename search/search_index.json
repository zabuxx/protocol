{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rarible Protocol \u00b6 Rarible Multichain Protocol is a decentralized toolset that simplifies the way developers can work with NFTs. Protocol builds an abstraction layer for several blockchains and isolates the developer from their specifics with Multichain SDK. Rarible Multichain SDK is fully blockchain-agnostic. You can find a list of supported blockchains on our Features page. How to start \u00b6 Read Getting Started guide to learn how to Install Multichain SDK , mint your first NFT and put it on sale Get better understanding of Rarible Multichain Protocol with Protocol Overview Chapter Learn how to use SDK with our Reference Try using our API Review successful cases from our partners using Rarible Multichain Protocol in Use Cases section Try to look on fully functional Example Application If you still have questions, join open discussion on Community Resources .","title":"Home"},{"location":"#rarible-protocol","text":"Rarible Multichain Protocol is a decentralized toolset that simplifies the way developers can work with NFTs. Protocol builds an abstraction layer for several blockchains and isolates the developer from their specifics with Multichain SDK. Rarible Multichain SDK is fully blockchain-agnostic. You can find a list of supported blockchains on our Features page.","title":"Rarible Protocol"},{"location":"#how-to-start","text":"Read Getting Started guide to learn how to Install Multichain SDK , mint your first NFT and put it on sale Get better understanding of Rarible Multichain Protocol with Protocol Overview Chapter Learn how to use SDK with our Reference Try using our API Review successful cases from our partners using Rarible Multichain Protocol in Use Cases section Try to look on fully functional Example Application If you still have questions, join open discussion on Community Resources .","title":"How to start"},{"location":"LICENSE/","text":"GNU GENERAL PUBLIC LICENSE Version 3, 29 June 2007 Copyright (C) 2007 Free Software Foundation, Inc. https://fsf.org/ Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. Preamble The GNU General Public License is a free, copyleft license for software and other kinds of works. The licenses for most software and other practical works are designed to take away your freedom to share and change the works. By contrast, the GNU General Public License is intended to guarantee your freedom to share and change all versions of a program--to make sure it remains free software for all its users. We, the Free Software Foundation, use the GNU General Public License for most of our software; it applies also to any other work released this way by its authors. You can apply it to your programs, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for them if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs, and that you know you can do these things. To protect your rights, we need to prevent others from denying you these rights or asking you to surrender the rights. Therefore, you have certain responsibilities if you distribute copies of the software, or if you modify it: responsibilities to respect the freedom of others. For example, if you distribute copies of such a program, whether gratis or for a fee, you must pass on to the recipients the same freedoms that you received. You must make sure that they, too, receive or can get the source code. And you must show them these terms so they know their rights. Developers that use the GNU GPL protect your rights with two steps: (1) assert copyright on the software, and (2) offer you this License giving you legal permission to copy, distribute and/or modify it. For the developers' and authors' protection, the GPL clearly explains that there is no warranty for this free software. For both users' and authors' sake, the GPL requires that modified versions be marked as changed, so that their problems will not be attributed erroneously to authors of previous versions. Some devices are designed to deny users access to install or run modified versions of the software inside them, although the manufacturer can do so. This is fundamentally incompatible with the aim of protecting users' freedom to change the software. The systematic pattern of such abuse occurs in the area of products for individuals to use, which is precisely where it is most unacceptable. Therefore, we have designed this version of the GPL to prohibit the practice for those products. If such problems arise substantially in other domains, we stand ready to extend this provision to those domains in future versions of the GPL, as needed to protect the freedom of users. Finally, every program is threatened constantly by software patents. States should not allow patents to restrict development and use of software on general-purpose computers, but in those that do, we wish to avoid the special danger that patents applied to a free program could make it effectively proprietary. To prevent this, the GPL assures that patents cannot be used to render the program non-free. The precise terms and conditions for copying, distribution and modification follow. TERMS AND CONDITIONS Definitions. \"This License\" refers to version 3 of the GNU General Public License. \"Copyright\" also means copyright-like laws that apply to other kinds of works, such as semiconductor masks. \"The Program\" refers to any copyrightable work licensed under this License. Each licensee is addressed as \"you\". \"Licensees\" and \"recipients\" may be individuals or organizations. To \"modify\" a work means to copy from or adapt all or part of the work in a fashion requiring copyright permission, other than the making of an exact copy. The resulting work is called a \"modified version\" of the earlier work or a work \"based on\" the earlier work. A \"covered work\" means either the unmodified Program or a work based on the Program. To \"propagate\" a work means to do anything with it that, without permission, would make you directly or secondarily liable for infringement under applicable copyright law, except executing it on a computer or modifying a private copy. Propagation includes copying, distribution (with or without modification), making available to the public, and in some countries other activities as well. To \"convey\" a work means any kind of propagation that enables other parties to make or receive copies. Mere interaction with a user through a computer network, with no transfer of a copy, is not conveying. An interactive user interface displays \"Appropriate Legal Notices\" to the extent that it includes a convenient and prominently visible feature that (1) displays an appropriate copyright notice, and (2) tells the user that there is no warranty for the work (except to the extent that warranties are provided), that licensees may convey the work under this License, and how to view a copy of this License. If the interface presents a list of user commands or options, such as a menu, a prominent item in the list meets this criterion. Source Code. The \"source code\" for a work means the preferred form of the work for making modifications to it. \"Object code\" means any non-source form of a work. A \"Standard Interface\" means an interface that either is an official standard defined by a recognized standards body, or, in the case of interfaces specified for a particular programming language, one that is widely used among developers working in that language. The \"System Libraries\" of an executable work include anything, other than the work as a whole, that (a) is included in the normal form of packaging a Major Component, but which is not part of that Major Component, and (b) serves only to enable use of the work with that Major Component, or to implement a Standard Interface for which an implementation is available to the public in source code form. A \"Major Component\", in this context, means a major essential component (kernel, window system, and so on) of the specific operating system (if any) on which the executable work runs, or a compiler used to produce the work, or an object code interpreter used to run it. The \"Corresponding Source\" for a work in object code form means all the source code needed to generate, install, and (for an executable work) run the object code and to modify the work, including scripts to control those activities. However, it does not include the work's System Libraries, or general-purpose tools or generally available free programs which are used unmodified in performing those activities but which are not part of the work. For example, Corresponding Source includes interface definition files associated with source files for the work, and the source code for shared libraries and dynamically linked subprograms that the work is specifically designed to require, such as by intimate data communication or control flow between those subprograms and other parts of the work. The Corresponding Source need not include anything that users can regenerate automatically from other parts of the Corresponding Source. The Corresponding Source for a work in source code form is that same work. Basic Permissions. All rights granted under this License are granted for the term of copyright on the Program, and are irrevocable provided the stated conditions are met. This License explicitly affirms your unlimited permission to run the unmodified Program. The output from running a covered work is covered by this License only if the output, given its content, constitutes a covered work. This License acknowledges your rights of fair use or other equivalent, as provided by copyright law. You may make, run and propagate covered works that you do not convey, without conditions so long as your license otherwise remains in force. You may convey covered works to others for the sole purpose of having them make modifications exclusively for you, or provide you with facilities for running those works, provided that you comply with the terms of this License in conveying all material for which you do not control copyright. Those thus making or running the covered works for you must do so exclusively on your behalf, under your direction and control, on terms that prohibit them from making any copies of your copyrighted material outside their relationship with you. Conveying under any other circumstances is permitted solely under the conditions stated below. Sublicensing is not allowed; section 10 makes it unnecessary. Protecting Users' Legal Rights From Anti-Circumvention Law. No covered work shall be deemed part of an effective technological measure under any applicable law fulfilling obligations under article 11 of the WIPO copyright treaty adopted on 20 December 1996, or similar laws prohibiting or restricting circumvention of such measures. When you convey a covered work, you waive any legal power to forbid circumvention of technological measures to the extent such circumvention is effected by exercising rights under this License with respect to the covered work, and you disclaim any intention to limit operation or modification of the work as a means of enforcing, against the work's users, your or third parties' legal rights to forbid circumvention of technological measures. Conveying Verbatim Copies. You may convey verbatim copies of the Program's source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice; keep intact all notices stating that this License and any non-permissive terms added in accord with section 7 apply to the code; keep intact all notices of the absence of any warranty; and give all recipients a copy of this License along with the Program. You may charge any price or no price for each copy that you convey, and you may offer support or warranty protection for a fee. Conveying Modified Source Versions. You may convey a work based on the Program, or the modifications to produce it from the Program, in the form of source code under the terms of section 4, provided that you also meet all of these conditions: a) The work must carry prominent notices stating that you modified it, and giving a relevant date. b) The work must carry prominent notices stating that it is released under this License and any conditions added under section 7. This requirement modifies the requirement in section 4 to \"keep intact all notices\". c) You must license the entire work, as a whole, under this License to anyone who comes into possession of a copy. This License will therefore apply, along with any applicable section 7 additional terms, to the whole of the work, and all its parts, regardless of how they are packaged. This License gives no permission to license the work in any other way, but it does not invalidate such permission if you have separately received it. d) If the work has interactive user interfaces, each must display Appropriate Legal Notices; however, if the Program has interactive interfaces that do not display Appropriate Legal Notices, your work need not make them do so. A compilation of a covered work with other separate and independent works, which are not by their nature extensions of the covered work, and which are not combined with it such as to form a larger program, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the compilation and its resulting copyright are not used to limit the access or legal rights of the compilation's users beyond what the individual works permit. Inclusion of a covered work in an aggregate does not cause this License to apply to the other parts of the aggregate. Conveying Non-Source Forms. You may convey a covered work in object code form under the terms of sections 4 and 5, provided that you also convey the machine-readable Corresponding Source under the terms of this License, in one of these ways: a) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by the Corresponding Source fixed on a durable physical medium customarily used for software interchange. b) Convey the object code in, or embodied in, a physical product (including a physical distribution medium), accompanied by a written offer, valid for at least three years and valid for as long as you offer spare parts or customer support for that product model, to give anyone who possesses the object code either (1) a copy of the Corresponding Source for all the software in the product that is covered by this License, on a durable physical medium customarily used for software interchange, for a price no more than your reasonable cost of physically performing this conveying of source, or (2) access to copy the Corresponding Source from a network server at no charge. c) Convey individual copies of the object code with a copy of the written offer to provide the Corresponding Source. This alternative is allowed only occasionally and noncommercially, and only if you received the object code with such an offer, in accord with subsection 6b. d) Convey the object code by offering access from a designated place (gratis or for a charge), and offer equivalent access to the Corresponding Source in the same way through the same place at no further charge. You need not require recipients to copy the Corresponding Source along with the object code. If the place to copy the object code is a network server, the Corresponding Source may be on a different server (operated by you or a third party) that supports equivalent copying facilities, provided you maintain clear directions next to the object code saying where to find the Corresponding Source. Regardless of what server hosts the Corresponding Source, you remain obligated to ensure that it is available for as long as needed to satisfy these requirements. e) Convey the object code using peer-to-peer transmission, provided you inform other peers where the object code and Corresponding Source of the work are being offered to the general public at no charge under subsection 6d. A separable portion of the object code, whose source code is excluded from the Corresponding Source as a System Library, need not be included in conveying the object code work. A \"User Product\" is either (1) a \"consumer product\", which means any tangible personal property which is normally used for personal, family, or household purposes, or (2) anything designed or sold for incorporation into a dwelling. In determining whether a product is a consumer product, doubtful cases shall be resolved in favor of coverage. For a particular product received by a particular user, \"normally used\" refers to a typical or common use of that class of product, regardless of the status of the particular user or of the way in which the particular user actually uses, or expects or is expected to use, the product. A product is a consumer product regardless of whether the product has substantial commercial, industrial or non-consumer uses, unless such uses represent the only significant mode of use of the product. \"Installation Information\" for a User Product means any methods, procedures, authorization keys, or other information required to install and execute modified versions of a covered work in that User Product from a modified version of its Corresponding Source. The information must suffice to ensure that the continued functioning of the modified object code is in no case prevented or interfered with solely because modification has been made. If you convey an object code work under this section in, or with, or specifically for use in, a User Product, and the conveying occurs as part of a transaction in which the right of possession and use of the User Product is transferred to the recipient in perpetuity or for a fixed term (regardless of how the transaction is characterized), the Corresponding Source conveyed under this section must be accompanied by the Installation Information. But this requirement does not apply if neither you nor any third party retains the ability to install modified object code on the User Product (for example, the work has been installed in ROM). The requirement to provide Installation Information does not include a requirement to continue to provide support service, warranty, or updates for a work that has been modified or installed by the recipient, or for the User Product in which it has been modified or installed. Access to a network may be denied when the modification itself materially and adversely affects the operation of the network or violates the rules and protocols for communication across the network. Corresponding Source conveyed, and Installation Information provided, in accord with this section must be in a format that is publicly documented (and with an implementation available to the public in source code form), and must require no special password or key for unpacking, reading or copying. Additional Terms. \"Additional permissions\" are terms that supplement the terms of this License by making exceptions from one or more of its conditions. Additional permissions that are applicable to the entire Program shall be treated as though they were included in this License, to the extent that they are valid under applicable law. If additional permissions apply only to part of the Program, that part may be used separately under those permissions, but the entire Program remains governed by this License without regard to the additional permissions. When you convey a copy of a covered work, you may at your option remove any additional permissions from that copy, or from any part of it. (Additional permissions may be written to require their own removal in certain cases when you modify the work.) You may place additional permissions on material, added by you to a covered work, for which you have or can give appropriate copyright permission. Notwithstanding any other provision of this License, for material you add to a covered work, you may (if authorized by the copyright holders of that material) supplement the terms of this License with terms: a) Disclaiming warranty or limiting liability differently from the terms of sections 15 and 16 of this License; or b) Requiring preservation of specified reasonable legal notices or author attributions in that material or in the Appropriate Legal Notices displayed by works containing it; or c) Prohibiting misrepresentation of the origin of that material, or requiring that modified versions of such material be marked in reasonable ways as different from the original version; or d) Limiting the use for publicity purposes of names of licensors or authors of the material; or e) Declining to grant rights under trademark law for use of some trade names, trademarks, or service marks; or f) Requiring indemnification of licensors and authors of that material by anyone who conveys the material (or modified versions of it) with contractual assumptions of liability to the recipient, for any liability that these contractual assumptions directly impose on those licensors and authors. All other non-permissive additional terms are considered \"further restrictions\" within the meaning of section 10. If the Program as you received it, or any part of it, contains a notice stating that it is governed by this License along with a term that is a further restriction, you may remove that term. If a license document contains a further restriction but permits relicensing or conveying under this License, you may add to a covered work material governed by the terms of that license document, provided that the further restriction does not survive such relicensing or conveying. If you add terms to a covered work in accord with this section, you must place, in the relevant source files, a statement of the additional terms that apply to those files, or a notice indicating where to find the applicable terms. Additional terms, permissive or non-permissive, may be stated in the form of a separately written license, or stated as exceptions; the above requirements apply either way. Termination. You may not propagate or modify a covered work except as expressly provided under this License. Any attempt otherwise to propagate or modify it is void, and will automatically terminate your rights under this License (including any patent licenses granted under the third paragraph of section 11). However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, you do not qualify to receive new licenses for the same material under section 10. Acceptance Not Required for Having Copies. You are not required to accept this License in order to receive or run a copy of the Program. Ancillary propagation of a covered work occurring solely as a consequence of using peer-to-peer transmission to receive a copy likewise does not require acceptance. However, nothing other than this License grants you permission to propagate or modify any covered work. These actions infringe copyright if you do not accept this License. Therefore, by modifying or propagating a covered work, you indicate your acceptance of this License to do so. Automatic Licensing of Downstream Recipients. Each time you convey a covered work, the recipient automatically receives a license from the original licensors, to run, modify and propagate that work, subject to this License. You are not responsible for enforcing compliance by third parties with this License. An \"entity transaction\" is a transaction transferring control of an organization, or substantially all assets of one, or subdividing an organization, or merging organizations. If propagation of a covered work results from an entity transaction, each party to that transaction who receives a copy of the work also receives whatever licenses to the work the party's predecessor in interest had or could give under the previous paragraph, plus a right to possession of the Corresponding Source of the work from the predecessor in interest, if the predecessor has it or can get it with reasonable efforts. You may not impose any further restrictions on the exercise of the rights granted or affirmed under this License. For example, you may not impose a license fee, royalty, or other charge for exercise of rights granted under this License, and you may not initiate litigation (including a cross-claim or counterclaim in a lawsuit) alleging that any patent claim is infringed by making, using, selling, offering for sale, or importing the Program or any portion of it. Patents. A \"contributor\" is a copyright holder who authorizes use under this License of the Program or a work on which the Program is based. The work thus licensed is called the contributor's \"contributor version\". A contributor's \"essential patent claims\" are all patent claims owned or controlled by the contributor, whether already acquired or hereafter acquired, that would be infringed by some manner, permitted by this License, of making, using, or selling its contributor version, but do not include claims that would be infringed only as a consequence of further modification of the contributor version. For purposes of this definition, \"control\" includes the right to grant patent sublicenses in a manner consistent with the requirements of this License. Each contributor grants you a non-exclusive, worldwide, royalty-free patent license under the contributor's essential patent claims, to make, use, sell, offer for sale, import and otherwise run, modify and propagate the contents of its contributor version. In the following three paragraphs, a \"patent license\" is any express agreement or commitment, however denominated, not to enforce a patent (such as an express permission to practice a patent or covenant not to sue for patent infringement). To \"grant\" such a patent license to a party means to make such an agreement or commitment not to enforce a patent against the party. If you convey a covered work, knowingly relying on a patent license, and the Corresponding Source of the work is not available for anyone to copy, free of charge and under the terms of this License, through a publicly available network server or other readily accessible means, then you must either (1) cause the Corresponding Source to be so available, or (2) arrange to deprive yourself of the benefit of the patent license for this particular work, or (3) arrange, in a manner consistent with the requirements of this License, to extend the patent license to downstream recipients. \"Knowingly relying\" means you have actual knowledge that, but for the patent license, your conveying the covered work in a country, or your recipient's use of the covered work in a country, would infringe one or more identifiable patents in that country that you have reason to believe are valid. If, pursuant to or in connection with a single transaction or arrangement, you convey, or propagate by procuring conveyance of, a covered work, and grant a patent license to some of the parties receiving the covered work authorizing them to use, propagate, modify or convey a specific copy of the covered work, then the patent license you grant is automatically extended to all recipients of the covered work and works based on it. A patent license is \"discriminatory\" if it does not include within the scope of its coverage, prohibits the exercise of, or is conditioned on the non-exercise of one or more of the rights that are specifically granted under this License. You may not convey a covered work if you are a party to an arrangement with a third party that is in the business of distributing software, under which you make payment to the third party based on the extent of your activity of conveying the work, and under which the third party grants, to any of the parties who would receive the covered work from you, a discriminatory patent license (a) in connection with copies of the covered work conveyed by you (or copies made from those copies), or (b) primarily for and in connection with specific products or compilations that contain the covered work, unless you entered into that arrangement, or that patent license was granted, prior to 28 March 2007. Nothing in this License shall be construed as excluding or limiting any implied license or other defenses to infringement that may otherwise be available to you under applicable patent law. No Surrender of Others' Freedom. If conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot convey a covered work so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not convey it at all. For example, if you agree to terms that obligate you to collect a royalty for further conveying from those to whom you convey the Program, the only way you could satisfy both those terms and this License would be to refrain entirely from conveying the Program. Use with the GNU Affero General Public License. Notwithstanding any other provision of this License, you have permission to link or combine any covered work with a work licensed under version 3 of the GNU Affero General Public License into a single combined work, and to convey the resulting work. The terms of this License will continue to apply to the part which is the covered work, but the special requirements of the GNU Affero General Public License, section 13, concerning interaction through a network will apply to the combination as such. Revised Versions of this License. The Free Software Foundation may publish revised and/or new versions of the GNU General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Program specifies that a certain numbered version of the GNU General Public License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that numbered version or of any later version published by the Free Software Foundation. If the Program does not specify a version number of the GNU General Public License, you may choose any version ever published by the Free Software Foundation. If the Program specifies that a proxy can decide which future versions of the GNU General Public License can be used, that proxy's public statement of acceptance of a version permanently authorizes you to choose that version for the Program. Later license versions may give you additional or different permissions. However, no additional obligations are imposed on any author or copyright holder as a result of your choosing to follow a later version. Disclaimer of Warranty. THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. Limitation of Liability. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. Interpretation of Sections 15 and 16. If the disclaimer of warranty and limitation of liability provided above cannot be given local legal effect according to their terms, reviewing courts shall apply local law that most closely approximates an absolute waiver of all civil liability in connection with the Program, unless a warranty or assumption of liability accompanies a copy of the Program in return for a fee. END OF TERMS AND CONDITIONS How to Apply These Terms to Your New Programs If you develop a new program, and you want it to be of the greatest possible use to the public, the best way to achieve this is to make it free software which everyone can redistribute and change under these terms. To do so, attach the following notices to the program. It is safest to attach them to the start of each source file to most effectively state the exclusion of warranty; and each file should have at least the \"copyright\" line and a pointer to where the full notice is found. <one line to give the program's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see <https://www.gnu.org/licenses/>. Also add information on how to contact you by electronic and paper mail. If the program does terminal interaction, make it output a short notice like this when it starts in an interactive mode: <program> Copyright (C) <year> <name of author> This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'. This is free software, and you are welcome to redistribute it under certain conditions; type `show c' for details. The hypothetical commands show w' and show c' should show the appropriate parts of the General Public License. Of course, your program's commands might be different; for a GUI interface, you would use an \"about box\". You should also get your employer (if you work as a programmer) or school, if any, to sign a \"copyright disclaimer\" for the program, if necessary. For more information on this, and how to apply and follow the GNU GPL, see https://www.gnu.org/licenses/ . The GNU General Public License does not permit incorporating your program into proprietary programs. If your program is a subroutine library, you may consider it more useful to permit linking proprietary applications with the library. If this is what you want to do, use the GNU Lesser General Public License instead of this License. But first, please read https://www.gnu.org/licenses/why-not-lgpl.html .","title":"LICENSE"},{"location":"MIT-LICENSE/","text":"Copyright (c) 2021, Rarible DAO Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"MIT LICENSE"},{"location":"api-reference/","text":"API Reference \u00b6 Documentation and base URL \u00b6 Use these base URLs to access our API on different networks. api.rarible.org or any testnet equivalent is compatible with all blockchains supported by the Rarible Protocol. We also use the term multichain to describe this compatibility case in the docs. Documentation Base URL Environments https://multichain.redoc.ly/ For all environments https://api.rarible.org/v0.1/doc https://api.rarible.org/v0.1 Production (Mainnet) https://api-staging.rarible.org/v0.1/doc https://api-staging.rarible.org/v0.1 Staging (Rinkeby, Mumbai) https://api-dev.rarible.org/v0.1/doc https://api-dev.rarible.org/v0.1 Development (Ropsten, Mumbai, Hangzhou) https://api-e2e.rarible.org/v0.1/doc https://api-e2e.rarible.org/v0.1 e2e On the https://multichain.redoc.ly/ page, you can make API requests using the TryIt function. To start using: Change environments on the top left side Choose API method Click Try it button: Configure the request parameters if required Click Send button Also see additional information and API usage examples on the Search Capabilities page. Environments \u00b6 The API interacts with different blockchain networks for different environments. Production : Ethereum: mainnet Tezos: mainnet Flow: mainnet Polygon: mainnet Staging : Ethereum: rinkeby Flow: devnet Polygon: mumbai Development : Ethereum: ropsten Tezos: hangzhou Flow: devnet Polygon: mumbai","title":"API References"},{"location":"api-reference/#api-reference","text":"","title":"API Reference"},{"location":"api-reference/#documentation-and-base-url","text":"Use these base URLs to access our API on different networks. api.rarible.org or any testnet equivalent is compatible with all blockchains supported by the Rarible Protocol. We also use the term multichain to describe this compatibility case in the docs. Documentation Base URL Environments https://multichain.redoc.ly/ For all environments https://api.rarible.org/v0.1/doc https://api.rarible.org/v0.1 Production (Mainnet) https://api-staging.rarible.org/v0.1/doc https://api-staging.rarible.org/v0.1 Staging (Rinkeby, Mumbai) https://api-dev.rarible.org/v0.1/doc https://api-dev.rarible.org/v0.1 Development (Ropsten, Mumbai, Hangzhou) https://api-e2e.rarible.org/v0.1/doc https://api-e2e.rarible.org/v0.1 e2e On the https://multichain.redoc.ly/ page, you can make API requests using the TryIt function. To start using: Change environments on the top left side Choose API method Click Try it button: Configure the request parameters if required Click Send button Also see additional information and API usage examples on the Search Capabilities page.","title":"Documentation and base URL"},{"location":"api-reference/#environments","text":"The API interacts with different blockchain networks for different environments. Production : Ethereum: mainnet Tezos: mainnet Flow: mainnet Polygon: mainnet Staging : Ethereum: rinkeby Flow: devnet Polygon: mumbai Development : Ethereum: ropsten Tezos: hangzhou Flow: devnet Polygon: mumbai","title":"Environments"},{"location":"faq/","text":"Frequently Asked Questions \u00b6 See Discussion QA section on our GitHub repo, Discord , and documentation for more answers. If you haven't found an answer to your question, you can create a new discussion here . WIP. It's the first FAQ version. Do I need tokenId to lazy minting NFT through SDK? \u00b6 Token id is optional and generates inside the SDK if not provided. Just generate it using the API call and pass it to mint. How to connect Metamask with SDK? \u00b6 Something like that: new EthereumWallet(new Web3Ethereum({ web3: web31 })) Now you can pass your wallet to the create SDK factory. See Rarible Protocol SDK for more information about using SDK. Why the price in the sell order can't be updated to a higher value? \u00b6 That's a security issue. If you signed a message stating that you want to sell something for 1 ETH, you can't just ignore this and pretend that you want to sell for 1.5 ETH. If there is somewhere saved previous message, it can be used in the smart contract. So, to make the price higher, you should cancel the order and sign a new message. What does the union-service repo do? \u00b6 Multichain service also known as union service is a layer that connects different Blockchain APIs. It sits on top of all of them. What kind of fee model does the protocol use? \u00b6 See Smart contracts for Rarible protocol repo on GitHub for more information about fees. Also, you can find more information about fees in Rarible Protocol Ethereum docs. What is \"deploy\" in the SDK used for? \u00b6 It's used for deploying ERC-721/ERC-1155 token contracts. Users can deploy new collection contracts, for example.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"See Discussion QA section on our GitHub repo, Discord , and documentation for more answers. If you haven't found an answer to your question, you can create a new discussion here . WIP. It's the first FAQ version.","title":"Frequently Asked Questions"},{"location":"faq/#do-i-need-tokenid-to-lazy-minting-nft-through-sdk","text":"Token id is optional and generates inside the SDK if not provided. Just generate it using the API call and pass it to mint.","title":"Do I need tokenId to lazy minting NFT through SDK?"},{"location":"faq/#how-to-connect-metamask-with-sdk","text":"Something like that: new EthereumWallet(new Web3Ethereum({ web3: web31 })) Now you can pass your wallet to the create SDK factory. See Rarible Protocol SDK for more information about using SDK.","title":"How to connect Metamask with SDK?"},{"location":"faq/#why-the-price-in-the-sell-order-cant-be-updated-to-a-higher-value","text":"That's a security issue. If you signed a message stating that you want to sell something for 1 ETH, you can't just ignore this and pretend that you want to sell for 1.5 ETH. If there is somewhere saved previous message, it can be used in the smart contract. So, to make the price higher, you should cancel the order and sign a new message.","title":"Why the price in the sell order can't be updated to a higher value?"},{"location":"faq/#what-does-the-union-service-repo-do","text":"Multichain service also known as union service is a layer that connects different Blockchain APIs. It sits on top of all of them.","title":"What does the union-service repo do?"},{"location":"faq/#what-kind-of-fee-model-does-the-protocol-use","text":"See Smart contracts for Rarible protocol repo on GitHub for more information about fees. Also, you can find more information about fees in Rarible Protocol Ethereum docs.","title":"What kind of fee model does the protocol use?"},{"location":"faq/#what-is-deploy-in-the-sdk-used-for","text":"It's used for deploying ERC-721/ERC-1155 token contracts. Users can deploy new collection contracts, for example.","title":"What is \"deploy\" in the SDK used for?"},{"location":"features/","text":"Rarible Protocol Features List \u00b6 Ethereum Flow Tezos Polygon Solana (coming soon) Multichain Protocol supported features NFTs types ERC-721 , ERC-1155 Flow NFT standart FA2 (TZIP-012) ERC-721 , ERC-1155 Buy now Sell NFTs Bids 2022 Q2 Create, update and cancel orders Create NFT collection 2022 Q2 Mint NFTs Lazy mint NFTs Transfer NFTs Burn NFTs Fees and Royalties On-chain Auction 2022 Q2 2022 Q2 2022 Q2 2022 Q2 Seaching/Data retrieval features Search tokens by parameters Search blockchain events Search orders by parameters Create or update orders Get collections information Indexer Fetch NFTs from blockchain Fetch fungible tokens from blockchain 2022 Q1 Fetch balances Fetch Orders from the other marketplaces (on-chain) NFT Storefront Objkt 2022 Q2 fixed price sale Hic Et Nunc 2022 Q2 fixed price sale Fetch orders from the other marketplaces (off-chain) OpenSea OpenSea Additional NFT collections CryptoPunks MotoGP, Evolution, Mugen ARt, Vault by CNN, Starly, Matrix World Voucher, Matrix World Flow Fest, VersusArt, DisruptArt, OneFootball, Jambb, Fanfare, Chainmonsters, Barter Yard Club, ClosedSrc","title":"Features"},{"location":"features/#rarible-protocol-features-list","text":"Ethereum Flow Tezos Polygon Solana (coming soon) Multichain Protocol supported features NFTs types ERC-721 , ERC-1155 Flow NFT standart FA2 (TZIP-012) ERC-721 , ERC-1155 Buy now Sell NFTs Bids 2022 Q2 Create, update and cancel orders Create NFT collection 2022 Q2 Mint NFTs Lazy mint NFTs Transfer NFTs Burn NFTs Fees and Royalties On-chain Auction 2022 Q2 2022 Q2 2022 Q2 2022 Q2 Seaching/Data retrieval features Search tokens by parameters Search blockchain events Search orders by parameters Create or update orders Get collections information Indexer Fetch NFTs from blockchain Fetch fungible tokens from blockchain 2022 Q1 Fetch balances Fetch Orders from the other marketplaces (on-chain) NFT Storefront Objkt 2022 Q2 fixed price sale Hic Et Nunc 2022 Q2 fixed price sale Fetch orders from the other marketplaces (off-chain) OpenSea OpenSea Additional NFT collections CryptoPunks MotoGP, Evolution, Mugen ARt, Vault by CNN, Starly, Matrix World Voucher, Matrix World Flow Fest, VersusArt, DisruptArt, OneFootball, Jambb, Fanfare, Chainmonsters, Barter Yard Club, ClosedSrc","title":"Rarible Protocol Features List"},{"location":"roadmap/","text":"Rarible Protocol Roadmap \u00b6 Q1 2022 Q2 2022 Q3 2022 Whitelabel Closed beta Public beta Multichain vision Solana Immutable X NEAR Avalanche Algorand API keys and rate-limits Easy to host Protocol Status page & Monitoring Rarible API hosted at the node providers Shared order book between multiple instances Everything about NFTs On-chain auctions NFT Data & Analytics API Events for the Developers Protocol Hackathon","title":"Rarible Protocol Roadmap"},{"location":"roadmap/#rarible-protocol-roadmap","text":"Q1 2022 Q2 2022 Q3 2022 Whitelabel Closed beta Public beta Multichain vision Solana Immutable X NEAR Avalanche Algorand API keys and rate-limits Easy to host Protocol Status page & Monitoring Rarible API hosted at the node providers Shared order book between multiple instances Everything about NFTs On-chain auctions NFT Data & Analytics API Events for the Developers Protocol Hackathon","title":"Rarible Protocol Roadmap"},{"location":"getting-started/community/","text":"Community and resources \u00b6 DAO \u00b6 If you're a builder or you're looking to participate in the Rarible Protocol DAO, here are a few valuable places you'll find support and like-minded builders. Discord is one of the main places where the DAO is being organized, and builders take their first steps towards building with the protocol. Github is where everything lives. Since we are open-source, many resources and help from other builders are available there. Notion is the platform where we hold information for DAO members and $RARI token holders. OpenAPI is where we document the current API capabilities. DAO Twitter Resources \u00b6 Rarible Youtube Rarible Twitter Rarible Hackathon Docs HackMD by Isaac for Ethereum network. Submitting \u00b6 You are welcome to suggest features and report bugs found! You can do it here: Submit an issue Submit a question or suggestion Audits \u00b6 Rarible Protocol is audited. Check this report by ChainSecurity.com . License \u00b6 Rarible Protocol is available under GPL v3 . SDK and OpenAPI (with generated clients) are available under MIT .","title":"Community and resources"},{"location":"getting-started/community/#community-and-resources","text":"","title":"Community and resources"},{"location":"getting-started/community/#dao","text":"If you're a builder or you're looking to participate in the Rarible Protocol DAO, here are a few valuable places you'll find support and like-minded builders. Discord is one of the main places where the DAO is being organized, and builders take their first steps towards building with the protocol. Github is where everything lives. Since we are open-source, many resources and help from other builders are available there. Notion is the platform where we hold information for DAO members and $RARI token holders. OpenAPI is where we document the current API capabilities. DAO Twitter","title":"DAO"},{"location":"getting-started/community/#resources","text":"Rarible Youtube Rarible Twitter Rarible Hackathon Docs HackMD by Isaac for Ethereum network.","title":"Resources"},{"location":"getting-started/community/#submitting","text":"You are welcome to suggest features and report bugs found! You can do it here: Submit an issue Submit a question or suggestion","title":"Submitting"},{"location":"getting-started/community/#audits","text":"Rarible Protocol is audited. Check this report by ChainSecurity.com .","title":"Audits"},{"location":"getting-started/community/#license","text":"Rarible Protocol is available under GPL v3 . SDK and OpenAPI (with generated clients) are available under MIT .","title":"License"},{"location":"getting-started/glossary/","text":"Glossary \u00b6 This document contains a glossary with an alphabetical list, definitions, and terms related to API. A | B | C | E | I | F | L | M | N | O | P | R | S | T A \u00b6 API Application Programming Interface enables different systems to interact with each other programmatically. Activity Event history with orders or NFT tokens. Asset Type Type of asset on the blockchain (NFT, Fungible Token, Native token, etc.). Asset Class Class of blockchain Assets (Ethereum, ERC20, ERC721, FA2, etc.). B \u00b6 Bid Offer a certain amount in cryptocurrency for an NFT token, and compete with other people to buy it. Burn Burning NFT effectively destroys the token and removes it entirely from the blockchain. C \u00b6 Collection NFTs are grouped in collections. Usually, in Rarible Protocol, collections are smart contracts in which NFTs are minted. Continuation Continuation token from the previous response. Contract Address of the Smart Contract. Creator Address of the NFT item creator. E \u00b6 ERC-20 The standard for fungible tokens. They have a property that makes each token the same (in type and value) as another token. ERC-721 The standard for NFT. This token type is unique and can have a different value than another token from the same smart contract. ERC-1155 The multi-token standard for NFT. A single deployed contract may include any combination of fungible tokens, non-fungible tokens, or other configurations. I \u00b6 Item Address of the NFT item. Id of the Item has format ${contract}:${tokenId} . F \u00b6 Fee Fee value for the operation. It can be Protocol fees, Origin fees, or Royalties. L \u00b6 Lazy Mint The way to defer the cost of minting an NFT until the moment it's sold to its first buyer. The gas fee for minting is included in the same transaction that assigns the NFT to the buyer. M \u00b6 Make Make the side of the Order. Make - what maker (order creator) has. Maker Creator of the order. Mint, Minting Minting is the act of publishing a unique instance of the token on the blockchain. N \u00b6 NFT Non-Fungible Tokens are one-of-a-kind tokens that represent a unique good or asset, like digital art. O \u00b6 Origin Fee Extra fee that can be included in the order. This fee will be paid by exchange smart contract when order is matched. Usually, frontends can include custom origin fees to monetize. Owner Address of the NFT item owner. Ownership Entity which links owner and NFT (Item). It holds value - the amount of NFTs owned by the user. Id of the Ownership has format ${contract}:${tokenId}:${owner} . P \u00b6 Payouts Who will benefit when order is matched. If payouts are not specified, then order maker is the beneficiary. Otherwise, order maker can redirect payouts of assets to other user or users. Platform The platform where the order was created. R \u00b6 Royalties Fees that are usually paid to the creator on every sale. S \u00b6 Salt Salt is a string of data that is passed to the hash function along with the input array of data to calculate the hash. Smart Contract The programs stored on a blockchain that run when predetermined conditions are met. Supply Total number of tokens minted or to be minted. T \u00b6 Take Take the side of the order, what order creator wants to get in return for make side. Token ID Token identifier.","title":"Rarible Protocol Glossary"},{"location":"getting-started/glossary/#glossary","text":"This document contains a glossary with an alphabetical list, definitions, and terms related to API. A | B | C | E | I | F | L | M | N | O | P | R | S | T","title":"Glossary"},{"location":"getting-started/glossary/#a","text":"API Application Programming Interface enables different systems to interact with each other programmatically. Activity Event history with orders or NFT tokens. Asset Type Type of asset on the blockchain (NFT, Fungible Token, Native token, etc.). Asset Class Class of blockchain Assets (Ethereum, ERC20, ERC721, FA2, etc.).","title":"A"},{"location":"getting-started/glossary/#b","text":"Bid Offer a certain amount in cryptocurrency for an NFT token, and compete with other people to buy it. Burn Burning NFT effectively destroys the token and removes it entirely from the blockchain.","title":"B"},{"location":"getting-started/glossary/#c","text":"Collection NFTs are grouped in collections. Usually, in Rarible Protocol, collections are smart contracts in which NFTs are minted. Continuation Continuation token from the previous response. Contract Address of the Smart Contract. Creator Address of the NFT item creator.","title":"C"},{"location":"getting-started/glossary/#e","text":"ERC-20 The standard for fungible tokens. They have a property that makes each token the same (in type and value) as another token. ERC-721 The standard for NFT. This token type is unique and can have a different value than another token from the same smart contract. ERC-1155 The multi-token standard for NFT. A single deployed contract may include any combination of fungible tokens, non-fungible tokens, or other configurations.","title":"E"},{"location":"getting-started/glossary/#i","text":"Item Address of the NFT item. Id of the Item has format ${contract}:${tokenId} .","title":"I"},{"location":"getting-started/glossary/#f","text":"Fee Fee value for the operation. It can be Protocol fees, Origin fees, or Royalties.","title":"F"},{"location":"getting-started/glossary/#l","text":"Lazy Mint The way to defer the cost of minting an NFT until the moment it's sold to its first buyer. The gas fee for minting is included in the same transaction that assigns the NFT to the buyer.","title":"L"},{"location":"getting-started/glossary/#m","text":"Make Make the side of the Order. Make - what maker (order creator) has. Maker Creator of the order. Mint, Minting Minting is the act of publishing a unique instance of the token on the blockchain.","title":"M"},{"location":"getting-started/glossary/#n","text":"NFT Non-Fungible Tokens are one-of-a-kind tokens that represent a unique good or asset, like digital art.","title":"N"},{"location":"getting-started/glossary/#o","text":"Origin Fee Extra fee that can be included in the order. This fee will be paid by exchange smart contract when order is matched. Usually, frontends can include custom origin fees to monetize. Owner Address of the NFT item owner. Ownership Entity which links owner and NFT (Item). It holds value - the amount of NFTs owned by the user. Id of the Ownership has format ${contract}:${tokenId}:${owner} .","title":"O"},{"location":"getting-started/glossary/#p","text":"Payouts Who will benefit when order is matched. If payouts are not specified, then order maker is the beneficiary. Otherwise, order maker can redirect payouts of assets to other user or users. Platform The platform where the order was created.","title":"P"},{"location":"getting-started/glossary/#r","text":"Royalties Fees that are usually paid to the creator on every sale.","title":"R"},{"location":"getting-started/glossary/#s","text":"Salt Salt is a string of data that is passed to the hash function along with the input array of data to calculate the hash. Smart Contract The programs stored on a blockchain that run when predetermined conditions are met. Supply Total number of tokens minted or to be minted.","title":"S"},{"location":"getting-started/glossary/#t","text":"Take Take the side of the order, what order creator wants to get in return for make side. Token ID Token identifier.","title":"T"},{"location":"getting-started/ipfs-example/","text":"Example of uploading & using Metadata with IPFS \u00b6 Uploading images to IPFS \u00b6 To upload images to IPFS, we will use the Pinata service. Here you can see an example using Node JS to upload an image using the Pinata API. const axios = require ( \"axios\" ); const fs = require ( \"fs\" ); const FormData = require ( \"form-data\" ); export const pinFileToIPFS = ( pinataApiKey , pinataSecretApiKey ) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS` ; let data = new FormData (); data . append ( \"file\" , fs . createReadStream ( \"./yourfile.png\" )); return axios . post ( url , data , { headers : { \"Content-Type\" : `multipart/form-data; boundary= ${ data . _boundary } ` , pinata_api_key : pinataApiKey , pinata_secret_api_key : pinataSecretApiKey , }, }) . then ( function ( response ) { console . log ( repsonse . IpfsHash ); }) . catch ( function ( error ) { console . log ( error ) }); }; Response to the request: { IpfsHash : // This is the IPFS multi-hash provided back for your content, PinSize : // This is how large (in bytes) the content you just pinned is, Timestamp : // This is the timestamp for your content pinning (represented in ISO 8601 format) } Creating a Metadata file for NFT \u00b6 With the IpfsHash , we can create a Metadata file. It will be connected to the NFT inside the blockchain network. { \"name\" : /* NFT Name - This must be a string */ , \"description\" : /* Description of the NFT - This must be a string */ , \"image\" : /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */ , \"external_url\" : /* This is the link to Rarible which we currently don't have, we can fill this in shortly */ , \"animation_url\" : /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */ , // the below section is not needed. \"attributes\" : [ { \"key\" : /* Key name - This must be a string */ , \"trait_type\" : /* Trait name - This must be a string */ , \"value\" : /* Key Value - This must be a string */ } ] } Adding generated Metadata to IPFS \u00b6 Specify external_url in the format ${contractAddress}:${tokenId} , for example: \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Publish Metadata to IPFS: var axios = require ( 'axios' ); var data = JSON . stringify ({ \"name\" : \"Test NFT\" , \"description\" : \"Test NFT\" , \"image\" : \"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\" , \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" , \"attributes\" : [{ \"key\" : \"Test\" , \"trait_type\" : \"Test\" , \"value\" : \"Test\" }]}); var config = { method : 'post' , url : 'https://api.pinata.cloud/pinning/pinFileToIPFS' , headers : { 'pinata_api_key' : // KEY_HERE, 'pinata_secret_api_key' : // SECRET_KEY_HERE, 'Content-Type' : 'application/json' }, data : data }; axios ( config ). then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }). catch ( function ( error ) { console . log ( error ); }); Response example: { \"IpfsHash\" : \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\" , \"PinSize\" : 290 , \"Timestamp\" : \"2021-02-10T14:06:09.255Z\" } Attach the new IpfsHash to your NFT.","title":"Example of uploading & using Metadata with IPFS"},{"location":"getting-started/ipfs-example/#example-of-uploading-using-metadata-with-ipfs","text":"","title":"Example of uploading &amp; using Metadata with IPFS"},{"location":"getting-started/ipfs-example/#uploading-images-to-ipfs","text":"To upload images to IPFS, we will use the Pinata service. Here you can see an example using Node JS to upload an image using the Pinata API. const axios = require ( \"axios\" ); const fs = require ( \"fs\" ); const FormData = require ( \"form-data\" ); export const pinFileToIPFS = ( pinataApiKey , pinataSecretApiKey ) => { const url = `https://api.pinata.cloud/pinning/pinJSONToIPFS` ; let data = new FormData (); data . append ( \"file\" , fs . createReadStream ( \"./yourfile.png\" )); return axios . post ( url , data , { headers : { \"Content-Type\" : `multipart/form-data; boundary= ${ data . _boundary } ` , pinata_api_key : pinataApiKey , pinata_secret_api_key : pinataSecretApiKey , }, }) . then ( function ( response ) { console . log ( repsonse . IpfsHash ); }) . catch ( function ( error ) { console . log ( error ) }); }; Response to the request: { IpfsHash : // This is the IPFS multi-hash provided back for your content, PinSize : // This is how large (in bytes) the content you just pinned is, Timestamp : // This is the timestamp for your content pinning (represented in ISO 8601 format) }","title":"Uploading images to IPFS"},{"location":"getting-started/ipfs-example/#creating-a-metadata-file-for-nft","text":"With the IpfsHash , we can create a Metadata file. It will be connected to the NFT inside the blockchain network. { \"name\" : /* NFT Name - This must be a string */ , \"description\" : /* Description of the NFT - This must be a string */ , \"image\" : /* IPFS Hash to our content, this must be prefixed with \"ipfs://ipfs/{{ IPFS_HASH ))\" - This must be a string */ , \"external_url\" : /* This is the link to Rarible which we currently don't have, we can fill this in shortly */ , \"animation_url\" : /* IPFS Hash just as image field, but it allows every type of multimedia files. Like mp3, mp4 etc */ , // the below section is not needed. \"attributes\" : [ { \"key\" : /* Key name - This must be a string */ , \"trait_type\" : /* Trait name - This must be a string */ , \"value\" : /* Key Value - This must be a string */ } ] }","title":"Creating a Metadata file for NFT"},{"location":"getting-started/ipfs-example/#adding-generated-metadata-to-ipfs","text":"Specify external_url in the format ${contractAddress}:${tokenId} , for example: \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" Publish Metadata to IPFS: var axios = require ( 'axios' ); var data = JSON . stringify ({ \"name\" : \"Test NFT\" , \"description\" : \"Test NFT\" , \"image\" : \"ipfs://ipfs/QmW4P1Mgoka8NRCsFAaJt5AaR6XKF6Az97uCiVtGmg1FuG/image.png\" , \"external_url\" : \"https://app.rarible.com/0x60f80121c31a0d46b5279700f9df786054aa5ee5:123913\" , \"attributes\" : [{ \"key\" : \"Test\" , \"trait_type\" : \"Test\" , \"value\" : \"Test\" }]}); var config = { method : 'post' , url : 'https://api.pinata.cloud/pinning/pinFileToIPFS' , headers : { 'pinata_api_key' : // KEY_HERE, 'pinata_secret_api_key' : // SECRET_KEY_HERE, 'Content-Type' : 'application/json' }, data : data }; axios ( config ). then ( function ( response ) { console . log ( JSON . stringify ( response . data )); }). catch ( function ( error ) { console . log ( error ); }); Response example: { \"IpfsHash\" : \"QmNybufJtuvWCZ355HGejvKfUXK8VeLcPA5G7CxT9MXJJp\" , \"PinSize\" : 290 , \"Timestamp\" : \"2021-02-10T14:06:09.255Z\" } Attach the new IpfsHash to your NFT.","title":"Adding generated Metadata to IPFS"},{"location":"getting-started/managing-sdk/","text":"Managing SDK and connecting blockchain wallets \u00b6 We're glad you're here! It means that you gave us a chance. Now it's our turn. You are able to do cool things with NFTs using Rarible Protocol like: minting burning selling transferring And basically, everything else that you can imagine. There is just one step in-between, which is setting up an SDK. The fastest way to set up Multichain SDK is to clone the template which we prepared for you. It already has all the necessary packages installed. Configure all wallets you want to use \u00b6 In order to add a wallet of your choice (like fcl, mew, beacon, flow) you have to append chain it into Connector create in src/sdk/connectors-setup file. In sdk-template there is only Metamask implemented, if you want to add other ones, please refer to official tutorial there . // Example of adding new wallet handler function mapEthereumWallet < O > ( provider : AbstractConnectionProvider < O , EthereumProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map (( state ) => ({ wallet : new EthereumWallet ( new Web3Ethereum ({ web3 : new Web3 ( state . provider ), from : state.address }) ), address : state.address , })); } const mew = mapEthereumWallet ( new MEWConnectionProvider ({ networkId : 4 , rpcUrl : ethereumRpcMap [ 4 ], }) ); After adding all the desired wallets, you have to chain them to the connector, with Metamask being first, in create method. It should look like that: // Adding all wallets which you've earlier initalised const connector = Connector . create ( injected , state ) . add ( torus ) . add ( walletLink ) . add ( mew ) . add ( beacon ) . add ( fcl ) . add ( walletConnect ); Changing buttons appearance \u00b6 If you want to change buttons appearance (e.g. different one for Metamask, different one for flow), you can do it in src/sdk/sdk-wallet-connector file. To be precise, you can do it in the Options function, right where you see the o.option. Feel free to create a component for every button and just switch the o.option which basically is just a string literal of the wallet i.e. \"Metamask\", \"fcl\", etc. function Options < C > ({ connector , connectionState } : OptionsProps < C > ) { const options$ = useMemo (() => from ( connector . getOptions ()), [ connector ]); return ( < Rx value$ = { options$ } > {( options ) => ( < div > { options . map (( o ) => ( < div key = { o . option } > < button className = \"p-2 border-radius border-gray-200 border-2\" onClick = {() => connector . connect ( o )} > Connect to { o . option } < /button> { connectionState . status === \"connecting\" && connectionState . providerId === o . provider . getId () ? \"Connecting...\" : null } < /div> ))} < /div> )} < /Rx> ); } App setup \u00b6 function MyApp ({ Component , pageProps }) { return ( < SdkWalletConnector connector = { connector } > {( sdk , wallet , connection ) => { return ( < SDKContext . Provider value = {{ sdk , wallet , connection }} > < Component {... pageProps } /> < /SDKContext.Provider> ); }} < /SdkWalletConnector> ); } Setup of an App is pretty easy, you basically don't have to change anything there, but if you're curious \u2014 SdkWalletConnector is a file where we create buttons from a connector that we defined in the first step. It's responsible for showing a different view according to the current connection state. If the user has not connected his wallet, yet it will show a different view, and if he has connected his wallet it will show a Component function, which in that is just the desired page, on which we'll be able to use an SDK. SDKContext is just a wrapper that holds information about SDK, wallet, and connection, so you can easily, and without any trouble, use it on every page. // Just like that const { sdk , wallet } = useSdkContext (); TLDR \u00b6 When setting up the SDK, there are three main files: connectors-setup \u2014 responsible for desired wallet's configuration sdk-wallet-connector \u2014 responsible for buttons appearance and wrapping a whole app app.js \u2014 which we wrap inside SDKWalletConnector and SDKContext , so we can have easy access to SDK on every page from now on","title":"Managing SDK ang connecting blockchain wallets"},{"location":"getting-started/managing-sdk/#managing-sdk-and-connecting-blockchain-wallets","text":"We're glad you're here! It means that you gave us a chance. Now it's our turn. You are able to do cool things with NFTs using Rarible Protocol like: minting burning selling transferring And basically, everything else that you can imagine. There is just one step in-between, which is setting up an SDK. The fastest way to set up Multichain SDK is to clone the template which we prepared for you. It already has all the necessary packages installed.","title":"Managing SDK and connecting blockchain wallets"},{"location":"getting-started/managing-sdk/#configure-all-wallets-you-want-to-use","text":"In order to add a wallet of your choice (like fcl, mew, beacon, flow) you have to append chain it into Connector create in src/sdk/connectors-setup file. In sdk-template there is only Metamask implemented, if you want to add other ones, please refer to official tutorial there . // Example of adding new wallet handler function mapEthereumWallet < O > ( provider : AbstractConnectionProvider < O , EthereumProviderConnectionResult > ) : ConnectionProvider < O , WalletAndAddress > { return provider . map (( state ) => ({ wallet : new EthereumWallet ( new Web3Ethereum ({ web3 : new Web3 ( state . provider ), from : state.address }) ), address : state.address , })); } const mew = mapEthereumWallet ( new MEWConnectionProvider ({ networkId : 4 , rpcUrl : ethereumRpcMap [ 4 ], }) ); After adding all the desired wallets, you have to chain them to the connector, with Metamask being first, in create method. It should look like that: // Adding all wallets which you've earlier initalised const connector = Connector . create ( injected , state ) . add ( torus ) . add ( walletLink ) . add ( mew ) . add ( beacon ) . add ( fcl ) . add ( walletConnect );","title":"Configure all wallets you want to use"},{"location":"getting-started/managing-sdk/#changing-buttons-appearance","text":"If you want to change buttons appearance (e.g. different one for Metamask, different one for flow), you can do it in src/sdk/sdk-wallet-connector file. To be precise, you can do it in the Options function, right where you see the o.option. Feel free to create a component for every button and just switch the o.option which basically is just a string literal of the wallet i.e. \"Metamask\", \"fcl\", etc. function Options < C > ({ connector , connectionState } : OptionsProps < C > ) { const options$ = useMemo (() => from ( connector . getOptions ()), [ connector ]); return ( < Rx value$ = { options$ } > {( options ) => ( < div > { options . map (( o ) => ( < div key = { o . option } > < button className = \"p-2 border-radius border-gray-200 border-2\" onClick = {() => connector . connect ( o )} > Connect to { o . option } < /button> { connectionState . status === \"connecting\" && connectionState . providerId === o . provider . getId () ? \"Connecting...\" : null } < /div> ))} < /div> )} < /Rx> ); }","title":"Changing buttons appearance"},{"location":"getting-started/managing-sdk/#app-setup","text":"function MyApp ({ Component , pageProps }) { return ( < SdkWalletConnector connector = { connector } > {( sdk , wallet , connection ) => { return ( < SDKContext . Provider value = {{ sdk , wallet , connection }} > < Component {... pageProps } /> < /SDKContext.Provider> ); }} < /SdkWalletConnector> ); } Setup of an App is pretty easy, you basically don't have to change anything there, but if you're curious \u2014 SdkWalletConnector is a file where we create buttons from a connector that we defined in the first step. It's responsible for showing a different view according to the current connection state. If the user has not connected his wallet, yet it will show a different view, and if he has connected his wallet it will show a Component function, which in that is just the desired page, on which we'll be able to use an SDK. SDKContext is just a wrapper that holds information about SDK, wallet, and connection, so you can easily, and without any trouble, use it on every page. // Just like that const { sdk , wallet } = useSdkContext ();","title":"App setup"},{"location":"getting-started/managing-sdk/#tldr","text":"When setting up the SDK, there are three main files: connectors-setup \u2014 responsible for desired wallet's configuration sdk-wallet-connector \u2014 responsible for buttons appearance and wrapping a whole app app.js \u2014 which we wrap inside SDKWalletConnector and SDKContext , so we can have easy access to SDK on every page from now on","title":"TLDR"},{"location":"getting-started/quick-start/","text":"Quick Start \u00b6 It's a Quick Start Guide for starting using Multichain SDK. We will create ERC-721 Lazy Minting NFT and list it in the Ethereum network to start using Multichain SDK. To get more information, use the links in each section. Installation \u00b6 npm install -D @rarible/sdk npm install web3@1.5.0 npm install tslib@2.3.1 or using yarn yarn add @rarible/sdk -D yarn add web3 yarn add tslib@2.3.1 Check that the SDK is installed correctly: npm view @rarible/sdk version Using SDK \u00b6 Create a project with the JS framework of your choice (we'll be using NextJS here). To properly set up the Rarible SDK, we need to follow standard Web3 practices. Grab the Ethereum object out of the global window object. Use it to create a new instance of Web3. Create a new instance of EthereumWallet class. Create Rarible SDK with a new instance of ethereumWallet, created in the previous step. In code, it looks like that (using TypeScript): // Imports import Web3 from \"web3\" import { createRaribleSdk } from \"@rarible/sdk\" import { EthereumWallet } from \"@rarible/sdk-wallet\" import { Blockchain } from \"@rarible/api-client\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" // Code const { ethereum } = window as any const web3 = new Web3 ( provider ) const web3Ethereum = new Web3Ethereum ({ web3 }) const ethWallet = new EthereumWallet ( web3Ethereum ) const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ) If using Ethers you should use @rarible/ethers-ethereum library for creating an EthereumWallet. Here is an example of creating all supported providers: // Imports import type Wallet from \"ethereumjs-wallet\" import Web3 from \"web3\" import { ethers } from \"ethers\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { EthersEthereum , EthersWeb3ProviderEthereum } from \"@rarible/ethers-ethereum\" // Code export function createProviders ( provider : any , wallet : Wallet ) { const web3 = new Web3 ( provider ) const ethersWeb3Provider = new ethers . providers . Web3Provider ( provider ) return { web3 , providers : [ new Web3Ethereum ({ web3 }), new EthersEthereum ( new ethers . Wallet ( wallet . getPrivateKeyString (), ethersWeb3Provider )), new EthersWeb3ProviderEthereum ( ethersWeb3Provider ), ], } } const ethWallet = new EthereumWallet ( ethersEthereumProviderInstance ) const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ) In createRaribleSdk , we have several environment parameters: prod (mainnet) dev (ropsten) staging (rinkeby) e2e The difference between them is the chain Id and the Rarible API endpoint. And if you're creating any blockchain application that will interact with users, you'll still need to implement the connect Metamask button to get their wallet connected. ERC-721 NFT Lazy Minting & Sell \u00b6 Often users want to list their NFTs on the sale right after creation. For this case, use mintAndSell function, which allows you to do exactly that. const currentWallet = wallet as EthereumWallet ; const makerAccount = await currentWallet . ethereum . getFrom (); // Price in ETH const price : number = 1 ; const mintRequest : PrepareMintRequest = { collectionId : toContractAddress ( \"ETHEREUM:CONTRACT_ADDRESS\" ), }; const ethCurrency : EthErc20AssetType = { \"@type\" : \"ERC20\" , contract : toContractAddress ( \"ETHEREUM:CONTRACT_ADDRESS\" ), }; const mintResponse = await sdk . nft . mintAndSell ( mintRequest ); const response = await mintResponse . submit ({ uri , supply : 1 , lazyMint : true , price , creators : [ { account : toUnionAddress ( `ETHEREUM: ${ makerAccount } ` ), value : 10000 , }, ], currency : ethCurrency , }); // Response: // ItemId // OrderId See Reference overview page for more information about SDK usage.","title":"Quick Start"},{"location":"getting-started/quick-start/#quick-start","text":"It's a Quick Start Guide for starting using Multichain SDK. We will create ERC-721 Lazy Minting NFT and list it in the Ethereum network to start using Multichain SDK. To get more information, use the links in each section.","title":"Quick Start"},{"location":"getting-started/quick-start/#installation","text":"npm install -D @rarible/sdk npm install web3@1.5.0 npm install tslib@2.3.1 or using yarn yarn add @rarible/sdk -D yarn add web3 yarn add tslib@2.3.1 Check that the SDK is installed correctly: npm view @rarible/sdk version","title":"Installation"},{"location":"getting-started/quick-start/#using-sdk","text":"Create a project with the JS framework of your choice (we'll be using NextJS here). To properly set up the Rarible SDK, we need to follow standard Web3 practices. Grab the Ethereum object out of the global window object. Use it to create a new instance of Web3. Create a new instance of EthereumWallet class. Create Rarible SDK with a new instance of ethereumWallet, created in the previous step. In code, it looks like that (using TypeScript): // Imports import Web3 from \"web3\" import { createRaribleSdk } from \"@rarible/sdk\" import { EthereumWallet } from \"@rarible/sdk-wallet\" import { Blockchain } from \"@rarible/api-client\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" // Code const { ethereum } = window as any const web3 = new Web3 ( provider ) const web3Ethereum = new Web3Ethereum ({ web3 }) const ethWallet = new EthereumWallet ( web3Ethereum ) const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ) If using Ethers you should use @rarible/ethers-ethereum library for creating an EthereumWallet. Here is an example of creating all supported providers: // Imports import type Wallet from \"ethereumjs-wallet\" import Web3 from \"web3\" import { ethers } from \"ethers\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { EthersEthereum , EthersWeb3ProviderEthereum } from \"@rarible/ethers-ethereum\" // Code export function createProviders ( provider : any , wallet : Wallet ) { const web3 = new Web3 ( provider ) const ethersWeb3Provider = new ethers . providers . Web3Provider ( provider ) return { web3 , providers : [ new Web3Ethereum ({ web3 }), new EthersEthereum ( new ethers . Wallet ( wallet . getPrivateKeyString (), ethersWeb3Provider )), new EthersWeb3ProviderEthereum ( ethersWeb3Provider ), ], } } const ethWallet = new EthereumWallet ( ethersEthereumProviderInstance ) const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ) In createRaribleSdk , we have several environment parameters: prod (mainnet) dev (ropsten) staging (rinkeby) e2e The difference between them is the chain Id and the Rarible API endpoint. And if you're creating any blockchain application that will interact with users, you'll still need to implement the connect Metamask button to get their wallet connected.","title":"Using SDK"},{"location":"getting-started/quick-start/#erc-721-nft-lazy-minting-sell","text":"Often users want to list their NFTs on the sale right after creation. For this case, use mintAndSell function, which allows you to do exactly that. const currentWallet = wallet as EthereumWallet ; const makerAccount = await currentWallet . ethereum . getFrom (); // Price in ETH const price : number = 1 ; const mintRequest : PrepareMintRequest = { collectionId : toContractAddress ( \"ETHEREUM:CONTRACT_ADDRESS\" ), }; const ethCurrency : EthErc20AssetType = { \"@type\" : \"ERC20\" , contract : toContractAddress ( \"ETHEREUM:CONTRACT_ADDRESS\" ), }; const mintResponse = await sdk . nft . mintAndSell ( mintRequest ); const response = await mintResponse . submit ({ uri , supply : 1 , lazyMint : true , price , creators : [ { account : toUnionAddress ( `ETHEREUM: ${ makerAccount } ` ), value : 10000 , }, ], currency : ethCurrency , }); // Response: // ItemId // OrderId See Reference overview page for more information about SDK usage.","title":"ERC-721 NFT Lazy Minting &amp; Sell"},{"location":"getting-started/royalties-on-a-external-collection/","text":"Setting Up Royalties on an External Collection \u00b6 Open the royalties contract in a new tab: https://etherscan.io/address/0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD#writeProxyContract Active Contract tab. Make sure Write as Proxy is selected near the top. Click Connect to Web3 . Expand the setRoyaltiesByToken function to set the royalties for the entire collection. You will now need to enter the collection address in the Token (Address) field followed by the tuple for royalties. An example of a tuple is below. The first part of the tuple must be the address where you'd like to receive the royalties. The second part is the percentage as Basis Points ie: 1000 = 10% Royalties. Below is an example of a tuple which gives the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) 1% royalties on items in the collection. The maximum royalties value is 10000 (100%). [[\"0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126\", 100]] In the screenshot below you can see that on the collection ( 0x4008c2482357632b06526b492c143f4e73ff1b0d ) the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) receives 2.5% (250) Royalties. Click on Write button which will bring up your connected wallet and ask you to pay gas fees to execute a transaction. Now that Royalties have been set up, royalties will be paid out on every sale in that collection. Below is an example of a purchase transaction with annotations on what each fee is for:","title":"Setting Up Royalties on an External Collection"},{"location":"getting-started/royalties-on-a-external-collection/#setting-up-royalties-on-an-external-collection","text":"Open the royalties contract in a new tab: https://etherscan.io/address/0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD#writeProxyContract Active Contract tab. Make sure Write as Proxy is selected near the top. Click Connect to Web3 . Expand the setRoyaltiesByToken function to set the royalties for the entire collection. You will now need to enter the collection address in the Token (Address) field followed by the tuple for royalties. An example of a tuple is below. The first part of the tuple must be the address where you'd like to receive the royalties. The second part is the percentage as Basis Points ie: 1000 = 10% Royalties. Below is an example of a tuple which gives the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) 1% royalties on items in the collection. The maximum royalties value is 10000 (100%). [[\"0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126\", 100]] In the screenshot below you can see that on the collection ( 0x4008c2482357632b06526b492c143f4e73ff1b0d ) the user ( 0x6C1AaC9EAd0a2c0D328309fbb2cf940F49d26126 ) receives 2.5% (250) Royalties. Click on Write button which will bring up your connected wallet and ask you to pay gas fees to execute a transaction. Now that Royalties have been set up, royalties will be paid out on every sale in that collection. Below is an example of a purchase transaction with annotations on what each fee is for:","title":"Setting Up Royalties on an External Collection"},{"location":"getting-started/sellOrder_acceptBid/","text":"Create Sell Order and Accept Bid \u00b6 After reading this piece of content you should have a knowledge about creating sell orders and accepting bids using Rarible Protocol. Executing actions \u00b6 You can use SDK to create (mint), trade, transfer, burn NFTs. All actions are handled in the same manner: Invoke function from SDK (e.g.: mint ). Async function returns so-called PrepareResponse (it's different for different actions). PrepareResponse contains all needed information to show user a form (for example, response for sell contains all supported currency types). Collect input from the user (show form and let user enter the data). Pass this data to submit Action. You can find more information about Action abstraction in dedicated [repo readme]. Or you can use it as a regular async function and work with regular Promises. Multichain \u00b6 Create Sell Order \u00b6 To create a sell order for NFT the following parameters are required: Item ID \u2014 Id of an item passed in blockchain:address:id manner, e.g. FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321 , Asset type - Asset which you want to receive for your NFT, e.g. FLOW_FT, ERC_20, Price - Amount of asset of your choice you want to receive, Contract Address - Address of a given asset format, e.g. for FLOW_FT, which stands for Flow Fungible Token (so just a flow token) you have to pass a contract of a flow token, which on testnet is as follows: A.7e60df042a9c0868.FlowToken . You can find all of the information about its contract addresses here: https://docs.onflow.org/core-contracts/flow-token/#gatsby-focus-wrapper Whenever you see the need for Multichain / Contract address, you can create it as follows: Blockchain Name Hex Address Example: BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 Get an id of the item you want to create a sell order for, e.g. by copying it from rarible URL when you're on your token, and create an orderRequest with that. The only difference between different blockchains is currency, i.e. asset which we want to receive in return for our NFT. It should look something like that: FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321 , ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:47 TEZOS:KT1BMB8m1QKqbbDDZPXpmGVCaM1cGcpTQSrw:443 import { toContractAddress , toItemId } from \"@rarible/types\" ; ... const itemId = \"FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321\" ; const orderRequest : PrepareOrderRequest = { itemId : toItemId ( itemId ); } Create a currency which you want to receive in return. Available ones: FlowAssetTypeNft, FlowAssetTypeFt, TezosXTZAssetType, etc. You can find all of them in node_modules/@rarible/api-client/build/models/AssetType.d.ts of you project. Additionally you're able to find all of the needed properties for them like tokenId, @type, or contract. const tezosAddress = \"TEZOS:KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS\" ; const flowAddress = \"FLOW:A.7e60df042a9c0868.FlowToken\" ; // ETH const currency : EthEthereumAssetType = { \"@type\" : \"ERC20\" , contract : } // TEZOS const currency : TezosFTAssetType = { \"@type\" : \"TEZOS_FT\" ; contract : toContractAddress ( tezosAddress ); tokenId? : 2321 ; } // FLOW const currency : FlowAssetTypeFt = { \"@type\" : \"FLOW_FT\" , contract : toContractAddress ( flowAddress ); }; Get sell response using orderRequest from earlier const sellResponse = await sdk . order . sell ( orderRequest ); // From sellResponse object you can get informations like: // is multiple sell order allowed // baseFee // maxAmount // originFeeSupport Example of response { \"multiple\" : false , \"supportedCurrencies\" : [ { \"blockchain\" : \"FLOW\" , \"type\" : \"NATIVE\" } ], \"baseFee\" : 250 , \"originFeeSupport\" : \"FULL\" , \"payoutsSupport\" : \"NONE\" , \"maxAmount\" : \"1\" } Execute submit method on sellResponse object const sellOrderCreated = await sellResponse . submit ({ price : 1 , amount : 1 , currency : currency , }); Example of response FLOW:33966044 Voila Accept Bid \u00b6 Accepting a bid codeflow is similar to the one in creating sell order. Codeflow is identical for all of the blockchains. Create fillRequest with an orderId which you want to accept const orderId = \"FLOW:32732635\" ; const fillRequest : PrepareFillRequest = { orderId : toOrderId ( orderId ), }; Get fillResponse using fillRequest const fillResponse = await sdk . order . acceptBid ( fillRequest ); Example of response { \"multiple\" : false , \"maxAmount\" : \"1\" , \"baseFee\" : 250 , \"supportsPartialFill\" : false , \"originFeeSupport\" : \"FULL\" , \"payoutsSupport\" : \"NONE\" } Submit received response const fillSubmitResponse = await fillResponse . submit ({ amount : 1 , });","title":"Create Sell Order and Accept Bid in Rarible Protocol"},{"location":"getting-started/sellOrder_acceptBid/#create-sell-order-and-accept-bid","text":"After reading this piece of content you should have a knowledge about creating sell orders and accepting bids using Rarible Protocol.","title":"Create Sell Order and Accept Bid"},{"location":"getting-started/sellOrder_acceptBid/#executing-actions","text":"You can use SDK to create (mint), trade, transfer, burn NFTs. All actions are handled in the same manner: Invoke function from SDK (e.g.: mint ). Async function returns so-called PrepareResponse (it's different for different actions). PrepareResponse contains all needed information to show user a form (for example, response for sell contains all supported currency types). Collect input from the user (show form and let user enter the data). Pass this data to submit Action. You can find more information about Action abstraction in dedicated [repo readme]. Or you can use it as a regular async function and work with regular Promises.","title":"Executing actions"},{"location":"getting-started/sellOrder_acceptBid/#multichain","text":"","title":"Multichain"},{"location":"getting-started/sellOrder_acceptBid/#create-sell-order","text":"To create a sell order for NFT the following parameters are required: Item ID \u2014 Id of an item passed in blockchain:address:id manner, e.g. FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321 , Asset type - Asset which you want to receive for your NFT, e.g. FLOW_FT, ERC_20, Price - Amount of asset of your choice you want to receive, Contract Address - Address of a given asset format, e.g. for FLOW_FT, which stands for Flow Fungible Token (so just a flow token) you have to pass a contract of a flow token, which on testnet is as follows: A.7e60df042a9c0868.FlowToken . You can find all of the information about its contract addresses here: https://docs.onflow.org/core-contracts/flow-token/#gatsby-focus-wrapper Whenever you see the need for Multichain / Contract address, you can create it as follows: Blockchain Name Hex Address Example: BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 Get an id of the item you want to create a sell order for, e.g. by copying it from rarible URL when you're on your token, and create an orderRequest with that. The only difference between different blockchains is currency, i.e. asset which we want to receive in return for our NFT. It should look something like that: FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321 , ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:47 TEZOS:KT1BMB8m1QKqbbDDZPXpmGVCaM1cGcpTQSrw:443 import { toContractAddress , toItemId } from \"@rarible/types\" ; ... const itemId = \"FLOW:A.ebf4ae01d1284af8.RaribleNFT:2321\" ; const orderRequest : PrepareOrderRequest = { itemId : toItemId ( itemId ); } Create a currency which you want to receive in return. Available ones: FlowAssetTypeNft, FlowAssetTypeFt, TezosXTZAssetType, etc. You can find all of them in node_modules/@rarible/api-client/build/models/AssetType.d.ts of you project. Additionally you're able to find all of the needed properties for them like tokenId, @type, or contract. const tezosAddress = \"TEZOS:KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS\" ; const flowAddress = \"FLOW:A.7e60df042a9c0868.FlowToken\" ; // ETH const currency : EthEthereumAssetType = { \"@type\" : \"ERC20\" , contract : } // TEZOS const currency : TezosFTAssetType = { \"@type\" : \"TEZOS_FT\" ; contract : toContractAddress ( tezosAddress ); tokenId? : 2321 ; } // FLOW const currency : FlowAssetTypeFt = { \"@type\" : \"FLOW_FT\" , contract : toContractAddress ( flowAddress ); }; Get sell response using orderRequest from earlier const sellResponse = await sdk . order . sell ( orderRequest ); // From sellResponse object you can get informations like: // is multiple sell order allowed // baseFee // maxAmount // originFeeSupport Example of response { \"multiple\" : false , \"supportedCurrencies\" : [ { \"blockchain\" : \"FLOW\" , \"type\" : \"NATIVE\" } ], \"baseFee\" : 250 , \"originFeeSupport\" : \"FULL\" , \"payoutsSupport\" : \"NONE\" , \"maxAmount\" : \"1\" } Execute submit method on sellResponse object const sellOrderCreated = await sellResponse . submit ({ price : 1 , amount : 1 , currency : currency , }); Example of response FLOW:33966044 Voila","title":"Create Sell Order"},{"location":"getting-started/sellOrder_acceptBid/#accept-bid","text":"Accepting a bid codeflow is similar to the one in creating sell order. Codeflow is identical for all of the blockchains. Create fillRequest with an orderId which you want to accept const orderId = \"FLOW:32732635\" ; const fillRequest : PrepareFillRequest = { orderId : toOrderId ( orderId ), }; Get fillResponse using fillRequest const fillResponse = await sdk . order . acceptBid ( fillRequest ); Example of response { \"multiple\" : false , \"maxAmount\" : \"1\" , \"baseFee\" : 250 , \"supportsPartialFill\" : false , \"originFeeSupport\" : \"FULL\" , \"payoutsSupport\" : \"NONE\" } Submit received response const fillSubmitResponse = await fillResponse . submit ({ amount : 1 , });","title":"Accept Bid"},{"location":"getting-started/unifiedTransfer/","text":"Transfering token between two addresses \u00b6 Process of transfering tokens between two addresses is straightforward. In order for the transfer to be successful it has to be created from an address to which an NFT belongs to. Signing of the transaction by the owner will also be required. Basically what we need is two things: itemId: which allows to uniquely identify any NFT on any blockchain, recipientAddress: which tells us where the token should be transfered. Create an ItemId & PrepareTransferRequest \u00b6 Item Id, as a lot of addresses in Rarible Protocol, consist of a few parts, separated by colon sign - ':'. We can create Item Id by merging: Blockchain name - ETHEREUM, TEZOS, FLOW, etc., Contract address - address of a smart contract responsible for NFT creation (you can find a smart contract address for specific blockchain here ), Token Id - id of minted / lazy minted token. So the ItemId, in theory, will look like that: {BLOCKCHAIN_NAME}:{CONTRACT_ADDRESS}:{TOKEN_ID} while in practice it can look like that: ETHEREUM : 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 : 55143609719300586327244080327388661151936544170854464635146779205246455382070 ; On the other hand we have a PrepareTransferRequest which is a simple object of PrepareTransferRequest type with an itemId property. In code you can do it like that: // Imports // unionAddress will be used and explained further in the article import { toItemId , toUnionAddress } from \"@rarible/types\" ; const itemId = \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382070\" ; const transferRequest : PrepareTransferRequest = { itemId : toItemId ( itemId ), }; Call sdk.nft.transfer method with transferRequest as an argument \u00b6 In the next step we take PrepareTransferRequest that we've created in previous step and use it to call sdk.nft.transfer method. It will return us a submit function as well as available options for that operation. const transferResponse = await sdk . nft . transfer ( transferRequest ); // Example of a response // { // \"multiple\": false, // \"maxAmount\": \"1\", // \"submit\": f() // } Call a submit function \u00b6 Now, there is one thing left and it is to call a submit function we previously fetched. This is the step which will trigger a Metamask window and a payment, since we're doing write operation on a blockchain (changing an owner is a write operation). Submit object consist of two parameters: to (required) - which is of type of UnifiedAddress {BLOCKCHAIN_NAME}:{ADDRESS}, amount - if the multiple flag from the previous step was true, it's possible to transfer more than one NFT, default to one. const response = await transferResponse . submit ({ to : toUnionAddress ( \"ETHEREUM:0x18c37f21D3C29f9a53A96CA678026DC660180065\" ), amount : 1 , }); // Example of a response // { // \"transaction\": { // \"receipt\": {}, // \"hash\": \"0xe78cb6963ac4c960c5c623d08d1407a\", // \"data\": \"0x832fbb2...\", // \"nonce\": 24, // \"from\": \"0x79ea2d536b5b7144a3eabdc6a7e43130199291c0\", // \"to\": \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" // }, // \"network\": \"rinkeby\", // \"blockchain\": \"ETHEREUM\" // } That's all in this section.","title":"Transfer tokens between addresses"},{"location":"getting-started/unifiedTransfer/#transfering-token-between-two-addresses","text":"Process of transfering tokens between two addresses is straightforward. In order for the transfer to be successful it has to be created from an address to which an NFT belongs to. Signing of the transaction by the owner will also be required. Basically what we need is two things: itemId: which allows to uniquely identify any NFT on any blockchain, recipientAddress: which tells us where the token should be transfered.","title":"Transfering token between two addresses"},{"location":"getting-started/unifiedTransfer/#create-an-itemid-preparetransferrequest","text":"Item Id, as a lot of addresses in Rarible Protocol, consist of a few parts, separated by colon sign - ':'. We can create Item Id by merging: Blockchain name - ETHEREUM, TEZOS, FLOW, etc., Contract address - address of a smart contract responsible for NFT creation (you can find a smart contract address for specific blockchain here ), Token Id - id of minted / lazy minted token. So the ItemId, in theory, will look like that: {BLOCKCHAIN_NAME}:{CONTRACT_ADDRESS}:{TOKEN_ID} while in practice it can look like that: ETHEREUM : 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 : 55143609719300586327244080327388661151936544170854464635146779205246455382070 ; On the other hand we have a PrepareTransferRequest which is a simple object of PrepareTransferRequest type with an itemId property. In code you can do it like that: // Imports // unionAddress will be used and explained further in the article import { toItemId , toUnionAddress } from \"@rarible/types\" ; const itemId = \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382070\" ; const transferRequest : PrepareTransferRequest = { itemId : toItemId ( itemId ), };","title":"Create an ItemId &amp; PrepareTransferRequest"},{"location":"getting-started/unifiedTransfer/#call-sdknfttransfer-method-with-transferrequest-as-an-argument","text":"In the next step we take PrepareTransferRequest that we've created in previous step and use it to call sdk.nft.transfer method. It will return us a submit function as well as available options for that operation. const transferResponse = await sdk . nft . transfer ( transferRequest ); // Example of a response // { // \"multiple\": false, // \"maxAmount\": \"1\", // \"submit\": f() // }","title":"Call sdk.nft.transfer method with transferRequest as an argument"},{"location":"getting-started/unifiedTransfer/#call-a-submit-function","text":"Now, there is one thing left and it is to call a submit function we previously fetched. This is the step which will trigger a Metamask window and a payment, since we're doing write operation on a blockchain (changing an owner is a write operation). Submit object consist of two parameters: to (required) - which is of type of UnifiedAddress {BLOCKCHAIN_NAME}:{ADDRESS}, amount - if the multiple flag from the previous step was true, it's possible to transfer more than one NFT, default to one. const response = await transferResponse . submit ({ to : toUnionAddress ( \"ETHEREUM:0x18c37f21D3C29f9a53A96CA678026DC660180065\" ), amount : 1 , }); // Example of a response // { // \"transaction\": { // \"receipt\": {}, // \"hash\": \"0xe78cb6963ac4c960c5c623d08d1407a\", // \"data\": \"0x832fbb2...\", // \"nonce\": 24, // \"from\": \"0x79ea2d536b5b7144a3eabdc6a7e43130199291c0\", // \"to\": \"0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" // }, // \"network\": \"rinkeby\", // \"blockchain\": \"ETHEREUM\" // } That's all in this section.","title":"Call a submit function"},{"location":"overview/architecture/","text":"Architecture \u00b6 Rarible Multichain protocol is built on 3-layer architecture: Blockchain Indexing Layer \u2013 a set of listeners to retrieve blockchain events process them and store in Rarible Database in a form of business objects Smart-Contracts \u2013 provide common logic to operate NFT-assets, e.g., minting, selling, transferring, auctions, etc. Multichain API \u2013 SDK for developers to use protocol capabilities in a simple blockchain-agnostic manner Protocol architecture The Protocol is primarily targeted to NFTs, but it's not limited to NFTs only. Any asset on EVM blockchain can be traded on Rarible. Rarible doing indexing per each blockchain integrated into protocol. Following events are listened: Block events Log events Rarible Multichain Protocol is fast performing and able to retrieve blocks with up to 2 seconds delay from blockchain. Blockchain restructuring is supported \u2013 changed blocks are indexed again to resolve discrepancies if any. Likewise, blockchain indexing Rarible protocol listens for most popular NFT-marketplaces to retrieve their order books, this helps to store in Rarible database both on-chain and off-chain information. Smart-contracts are constructed in the way to be upgradeable, orders have versioning information, so new fields can be added if needed in the future. All smart-contracts in Rarible before publishing pass mandatory security audit, so only verified reliable versions are provided with protocol. Multichain API provides blockchain agnostic SDK to: Search and retrieve business objects from Rarible Database (NFTs, orders, collections and detailed information about these objects) Perform on-chain actions \u2013 mint, sell, transfer NFTs Perform off-chain activities like lazy-minting Apply royalties and organize auctions In addition, Rarible Multichain Protocol provides information for dedicated customers to retrieve information about business objects changed immediately in publish-subscribe manner using Apache Kafka feed. Indexed events are sent to Apache Kafka in the same time they are stored in the database.","title":"Architecture"},{"location":"overview/architecture/#architecture","text":"Rarible Multichain protocol is built on 3-layer architecture: Blockchain Indexing Layer \u2013 a set of listeners to retrieve blockchain events process them and store in Rarible Database in a form of business objects Smart-Contracts \u2013 provide common logic to operate NFT-assets, e.g., minting, selling, transferring, auctions, etc. Multichain API \u2013 SDK for developers to use protocol capabilities in a simple blockchain-agnostic manner Protocol architecture The Protocol is primarily targeted to NFTs, but it's not limited to NFTs only. Any asset on EVM blockchain can be traded on Rarible. Rarible doing indexing per each blockchain integrated into protocol. Following events are listened: Block events Log events Rarible Multichain Protocol is fast performing and able to retrieve blocks with up to 2 seconds delay from blockchain. Blockchain restructuring is supported \u2013 changed blocks are indexed again to resolve discrepancies if any. Likewise, blockchain indexing Rarible protocol listens for most popular NFT-marketplaces to retrieve their order books, this helps to store in Rarible database both on-chain and off-chain information. Smart-contracts are constructed in the way to be upgradeable, orders have versioning information, so new fields can be added if needed in the future. All smart-contracts in Rarible before publishing pass mandatory security audit, so only verified reliable versions are provided with protocol. Multichain API provides blockchain agnostic SDK to: Search and retrieve business objects from Rarible Database (NFTs, orders, collections and detailed information about these objects) Perform on-chain actions \u2013 mint, sell, transfer NFTs Perform off-chain activities like lazy-minting Apply royalties and organize auctions In addition, Rarible Multichain Protocol provides information for dedicated customers to retrieve information about business objects changed immediately in publish-subscribe manner using Apache Kafka feed. Indexed events are sent to Apache Kafka in the same time they are stored in the database.","title":"Architecture"},{"location":"overview/auctions/","text":"Auctions \u00b6 Auctions types \u00b6 In Rarible Protocol implements English auction with fixed step. We have two AuctionHouse contracts for different type of sell asset. At that moment, we support English auction only for Ethereum and Polygon blockchains. AuctionHouse contracts types: AuctionHouse721 sell asset = ERC-721 buy asset = ETH or ERC-20 supports party bid AuctionHouse1155 sell asset = ERC-1155 buy asset = ETH or ERC-20 Features \u00b6 There are two parameters of AuctionHouse that are the same for all auctions and can be changed by AuctionHouse owner: minimalDuration \u2014 defines the minimal duration of auctions minimalStepBasePoint \u2014 is the minimal percentage increase between bids (in base points). For example, minimalStepBasePoint = 300 = 3%, first bid is 100 ETH, the second one should be not less than (100 + 100*3% =) 103 Auction time frame is decided by 2 parameters: duration mandatory parameter, that defines the duration of auction in seconds it must be between minimalDuration (default value is 15 days) and 1000 days (constant) startTime optional parameter that defines the start time an auction unix timestamp, can't be less than the time of creation of the auction So there are two cases of how the auction time frame can work: if startTime is 0, then the auction starts at the first bid that satisfies minimalPrice . Then the endTime is calculated at the moment of the first bid as well ( now + duration ) if startTime is set, then the endTime is calculated at the creation of an auction ( startTime + duration ) If a new bid is put when auction has less than minimalDuration left till endTime , then endTime = now + minimalDuration Data model \u00b6 Auction ERC721 \u00b6 address sellToken \u2014 sell asset contract address uint sellTokenId \u2014 sell asset tokenId address buyAsset \u2014 buy asset contract address if ERC20 (address(0) if buy asset = ETH) uint96 endTime \u2014 auction end time in unix timestamp Bid lastBid \u2014 last successful Bid address payable seller \u2014 seller address uint96 minimalPrice \u2014 minimal amount of the first bid address payable buyer \u2014 last successful bidder uint64 protocolFee \u2014 protocolFee at the time of auction creation bytes4 dataType \u2014 version of data field bytes data \u2014 encoded additional data, V1 fields uint originFee \u2014 auction origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient) uint duration \u2014 auction duration uint startTime \u2014 auction start time uint buyOutPrice \u2014 auction buyOut price (if bid amout > buyout price, then auction finishes and all transfers are done) AuctionERC1155 \u00b6 The main difference from struct Auction ERC721 is the additional field uint96 sellTokenValue address sellToken \u2014 sell asset contract address uint96 sellTokenValue \u2014 sell asset value uint sellTokenId \u2014 sell asset tokenId address buyAsset \u2014 buy asset contract address if ERC20 (address(0) if buy asset = ETH) uint96 endTime \u2014 auction end time in unix timestamp Bid lastBid \u2014 last successful Bid address payable seller \u2014 seller address uint96 minimalPrice \u2014 minimal amount of the first bid address payable buyer \u2014 last successful bidder uint64 protocolFee \u2014 protocolFee at the time of auction creation bytes4 dataType \u2014 version of data field bytes data \u2014 encoded additional data, V1 fields uint originFee \u2014 auction origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient) uint duration \u2014 auction duration uint startTime \u2014 auction start time uint buyOutPrice \u2014 auction buyOut price (if bid amout >= buyout price, then auction finishes and all transfers are done) Bid \u00b6 amount \u2014 bid amount dataType \u2014 version of data field data \u2014 encoded additional data, V1 fields uint originFee \u2014 bid origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient) Main functions \u00b6 startAuction start new auction emits event AuctionCreated(uint indexed auctionId, address seller, uint128 endTime) can be called from anyone arguments for ERC721 Auction address _sellToken \u2014 sell token address uint _sellTokenId \u2014 sell token Id address _buyAsset \u2014 buy asset address (0 if ETH) uint96 minimalPrice \u2014 minimal first bid price bytes4 dataType \u2014 data field type bytes memory data \u2014 additional Data arguments for ERC1155 Auction (1 additional field uint96 _sellTokenValue) address _sellToken \u2014 sell token address uint96 _sellTokenValue \u2014 sell token value uint _sellTokenId \u2014 sell token Id address _buyAsset \u2014 buy asset address (0 if ETH) uint96 minimalPrice \u2014 minimal first bid price bytes4 dataType \u2014 data field type bytes memory data \u2014 additional Data putBid puts bid on specific auction emits event BidPlaced(uint indexed auctionId, address seller, uint128 endTime) can be called from anyone arguments: _auctionId \u2014 auction Id bid \u2014 bid struct finishAuction finishes auction if it's ended(now > endTime) and has at least 1 bid emits event AuctionFinished(_auctionId) can be called from anyone arguments: _auctionId \u2014 auction Id buyOut buy out the sell item and finishes the auction emits event AuctionBuyOut(uint indexed auctionId, address buyer) emits event AuctionFinished(_auctionId) can be called from anyone arguments: _auctionId \u2014 auction Id bid \u2014 bid struct cancel finishes auction if it's not started and has no bids emits event AuctionCancelled(uint indexed auctionId) emits event AuctionFinished(_auctionId) can be called from auction creator arguments: _auctionId \u2014 auction Id","title":"Rarible Protocol Auctions"},{"location":"overview/auctions/#auctions","text":"","title":"Auctions"},{"location":"overview/auctions/#auctions-types","text":"In Rarible Protocol implements English auction with fixed step. We have two AuctionHouse contracts for different type of sell asset. At that moment, we support English auction only for Ethereum and Polygon blockchains. AuctionHouse contracts types: AuctionHouse721 sell asset = ERC-721 buy asset = ETH or ERC-20 supports party bid AuctionHouse1155 sell asset = ERC-1155 buy asset = ETH or ERC-20","title":"Auctions types"},{"location":"overview/auctions/#features","text":"There are two parameters of AuctionHouse that are the same for all auctions and can be changed by AuctionHouse owner: minimalDuration \u2014 defines the minimal duration of auctions minimalStepBasePoint \u2014 is the minimal percentage increase between bids (in base points). For example, minimalStepBasePoint = 300 = 3%, first bid is 100 ETH, the second one should be not less than (100 + 100*3% =) 103 Auction time frame is decided by 2 parameters: duration mandatory parameter, that defines the duration of auction in seconds it must be between minimalDuration (default value is 15 days) and 1000 days (constant) startTime optional parameter that defines the start time an auction unix timestamp, can't be less than the time of creation of the auction So there are two cases of how the auction time frame can work: if startTime is 0, then the auction starts at the first bid that satisfies minimalPrice . Then the endTime is calculated at the moment of the first bid as well ( now + duration ) if startTime is set, then the endTime is calculated at the creation of an auction ( startTime + duration ) If a new bid is put when auction has less than minimalDuration left till endTime , then endTime = now + minimalDuration","title":"Features"},{"location":"overview/auctions/#data-model","text":"","title":"Data model"},{"location":"overview/auctions/#auction-erc721","text":"address sellToken \u2014 sell asset contract address uint sellTokenId \u2014 sell asset tokenId address buyAsset \u2014 buy asset contract address if ERC20 (address(0) if buy asset = ETH) uint96 endTime \u2014 auction end time in unix timestamp Bid lastBid \u2014 last successful Bid address payable seller \u2014 seller address uint96 minimalPrice \u2014 minimal amount of the first bid address payable buyer \u2014 last successful bidder uint64 protocolFee \u2014 protocolFee at the time of auction creation bytes4 dataType \u2014 version of data field bytes data \u2014 encoded additional data, V1 fields uint originFee \u2014 auction origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient) uint duration \u2014 auction duration uint startTime \u2014 auction start time uint buyOutPrice \u2014 auction buyOut price (if bid amout > buyout price, then auction finishes and all transfers are done)","title":"Auction ERC721"},{"location":"overview/auctions/#auctionerc1155","text":"The main difference from struct Auction ERC721 is the additional field uint96 sellTokenValue address sellToken \u2014 sell asset contract address uint96 sellTokenValue \u2014 sell asset value uint sellTokenId \u2014 sell asset tokenId address buyAsset \u2014 buy asset contract address if ERC20 (address(0) if buy asset = ETH) uint96 endTime \u2014 auction end time in unix timestamp Bid lastBid \u2014 last successful Bid address payable seller \u2014 seller address uint96 minimalPrice \u2014 minimal amount of the first bid address payable buyer \u2014 last successful bidder uint64 protocolFee \u2014 protocolFee at the time of auction creation bytes4 dataType \u2014 version of data field bytes data \u2014 encoded additional data, V1 fields uint originFee \u2014 auction origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient) uint duration \u2014 auction duration uint startTime \u2014 auction start time uint buyOutPrice \u2014 auction buyOut price (if bid amout >= buyout price, then auction finishes and all transfers are done)","title":"AuctionERC1155"},{"location":"overview/auctions/#bid","text":"amount \u2014 bid amount dataType \u2014 version of data field data \u2014 encoded additional data, V1 fields uint originFee \u2014 bid origin fee in one uint slot (first 12 bytes store value, last 20 bytes store recipient)","title":"Bid"},{"location":"overview/auctions/#main-functions","text":"startAuction start new auction emits event AuctionCreated(uint indexed auctionId, address seller, uint128 endTime) can be called from anyone arguments for ERC721 Auction address _sellToken \u2014 sell token address uint _sellTokenId \u2014 sell token Id address _buyAsset \u2014 buy asset address (0 if ETH) uint96 minimalPrice \u2014 minimal first bid price bytes4 dataType \u2014 data field type bytes memory data \u2014 additional Data arguments for ERC1155 Auction (1 additional field uint96 _sellTokenValue) address _sellToken \u2014 sell token address uint96 _sellTokenValue \u2014 sell token value uint _sellTokenId \u2014 sell token Id address _buyAsset \u2014 buy asset address (0 if ETH) uint96 minimalPrice \u2014 minimal first bid price bytes4 dataType \u2014 data field type bytes memory data \u2014 additional Data putBid puts bid on specific auction emits event BidPlaced(uint indexed auctionId, address seller, uint128 endTime) can be called from anyone arguments: _auctionId \u2014 auction Id bid \u2014 bid struct finishAuction finishes auction if it's ended(now > endTime) and has at least 1 bid emits event AuctionFinished(_auctionId) can be called from anyone arguments: _auctionId \u2014 auction Id buyOut buy out the sell item and finishes the auction emits event AuctionBuyOut(uint indexed auctionId, address buyer) emits event AuctionFinished(_auctionId) can be called from anyone arguments: _auctionId \u2014 auction Id bid \u2014 bid struct cancel finishes auction if it's not started and has no bids emits event AuctionCancelled(uint indexed auctionId) emits event AuctionFinished(_auctionId) can be called from auction creator arguments: _auctionId \u2014 auction Id","title":"Main functions"},{"location":"overview/indexer/","text":"Indexer \u00b6 It's nice to think that every service in the crypto space is fully decentralized. Of course, it isn't. Just imagine looking through the Ethereum blockchain for specific information. Right now, i.e. 23.03.2022 the Ethereum blockchain size is almost 1 TB. It would be impossible to traverse that big chunk of a data in UX-friendly timeframe. That's why indexers originated. At the end of the day, what does indexing mean? It means to write data somewhere for later usage. In its essence, indexer take the data which we're interested in from blockchain (most of the time, we're not interested in every specific transaction, just the ones connected to our dApp), and saves it in some sort of database. It can be SQL or NoSQL \u2014 it doesn't really matter. What matters is that now, we have some sort of structure, which we can travel fast and efficiently. Rarible Multichain Indexer \u00b6 Now, when we're conscious about indexer responsibilities and duty, we can lean over what types of indexers are used in Rarible. On Rarible, we have three different types of indexers: NFT Indexer Token/Balance-Indexer Order Indexer Additionally, in order for the services to work, we have a MongoDB instance, where all the indexed data from different blockchains sits, and a Multichain SDK API which allows for data traversing. NFT Indexer \u00b6 NFT Indexer is used to index all history of NFTs related actions, i.e. mint, transfer and burn. Indexer gets logs from an Ethereum network, and accordingly creates NFT items in a NoSQL database. Especially, it listens to a change of a state of an NFT item ownership. Token/Balance-Indexer \u00b6 Token/Balance-Indexer is responsible for tracking user balances. If we mapped it to the Rarible usage, it checks if a user has enough of a given currency to make a bid. It handles all the information about a user's wallet status. Order Indexer \u00b6 In order to properly display order information (order means intent, e.g. intent to sell, or in simpler words, intent to sell an NFT for a given price), we need an order price in addition to other properties. That's where Order Indexer comes in. Listener catches logs which say e.g. if an order was executed, and what is the status of an order. It fetches order data from a few different places like OpenSea, Rarible OrderBook, or Cryptopunks. How does the indexer gather the data? \u00b6 It listens for specific events on a blockchain. Since every transaction and movement on a blockchain is emitted in a form of logs, and every log has its unique topic id, it can be explicitly identified. Moreover, the indexer is also listening for block creation events. Listening from two sources simultaneously gives us the certainty that we will manage to catch all events we're interested in. What events do the indexer listen to? \u00b6 Indexer listens mainly for transfer-type events. That's because almost all the NFT-related actions, including Minting, involve a transfer method, which creates an NFT (in that scenario we transfer the NFT from 0x0 address to the address of a creator). From fetched logs, the indexer creates item and ownership objects that it stores in a database. It also tracks events for a specific collection (Rarible collection, etc.) from which it creates a token entity, and stores it in a database as well. Multichain abstraction \u00b6 In order to be able to connect differently, not EVM based blockchains together, Rarible had to create a few different blockchain indexers. They all work based on the same principle, but since different blockchains like Tezos, Solana, Flow, have different architecture, they couldn't be simply merge. But the merge could be abstracted, and that's what Rarible has done. It created a service called Union, and it works as a \"really smart proxy\" which allows you to use one API for all the blockchains. It takes all the Kafka proxy topics, from all the blockchains, and merges it into one topic. That's how you're able to get info from all the blockchains by using one Multichain API.","title":"Indexer"},{"location":"overview/indexer/#indexer","text":"It's nice to think that every service in the crypto space is fully decentralized. Of course, it isn't. Just imagine looking through the Ethereum blockchain for specific information. Right now, i.e. 23.03.2022 the Ethereum blockchain size is almost 1 TB. It would be impossible to traverse that big chunk of a data in UX-friendly timeframe. That's why indexers originated. At the end of the day, what does indexing mean? It means to write data somewhere for later usage. In its essence, indexer take the data which we're interested in from blockchain (most of the time, we're not interested in every specific transaction, just the ones connected to our dApp), and saves it in some sort of database. It can be SQL or NoSQL \u2014 it doesn't really matter. What matters is that now, we have some sort of structure, which we can travel fast and efficiently.","title":"Indexer"},{"location":"overview/indexer/#rarible-multichain-indexer","text":"Now, when we're conscious about indexer responsibilities and duty, we can lean over what types of indexers are used in Rarible. On Rarible, we have three different types of indexers: NFT Indexer Token/Balance-Indexer Order Indexer Additionally, in order for the services to work, we have a MongoDB instance, where all the indexed data from different blockchains sits, and a Multichain SDK API which allows for data traversing.","title":"Rarible Multichain Indexer"},{"location":"overview/indexer/#nft-indexer","text":"NFT Indexer is used to index all history of NFTs related actions, i.e. mint, transfer and burn. Indexer gets logs from an Ethereum network, and accordingly creates NFT items in a NoSQL database. Especially, it listens to a change of a state of an NFT item ownership.","title":"NFT Indexer"},{"location":"overview/indexer/#tokenbalance-indexer","text":"Token/Balance-Indexer is responsible for tracking user balances. If we mapped it to the Rarible usage, it checks if a user has enough of a given currency to make a bid. It handles all the information about a user's wallet status.","title":"Token/Balance-Indexer"},{"location":"overview/indexer/#order-indexer","text":"In order to properly display order information (order means intent, e.g. intent to sell, or in simpler words, intent to sell an NFT for a given price), we need an order price in addition to other properties. That's where Order Indexer comes in. Listener catches logs which say e.g. if an order was executed, and what is the status of an order. It fetches order data from a few different places like OpenSea, Rarible OrderBook, or Cryptopunks.","title":"Order Indexer"},{"location":"overview/indexer/#how-does-the-indexer-gather-the-data","text":"It listens for specific events on a blockchain. Since every transaction and movement on a blockchain is emitted in a form of logs, and every log has its unique topic id, it can be explicitly identified. Moreover, the indexer is also listening for block creation events. Listening from two sources simultaneously gives us the certainty that we will manage to catch all events we're interested in.","title":"How does the indexer gather the data?"},{"location":"overview/indexer/#what-events-do-the-indexer-listen-to","text":"Indexer listens mainly for transfer-type events. That's because almost all the NFT-related actions, including Minting, involve a transfer method, which creates an NFT (in that scenario we transfer the NFT from 0x0 address to the address of a creator). From fetched logs, the indexer creates item and ownership objects that it stores in a database. It also tracks events for a specific collection (Rarible collection, etc.) from which it creates a token entity, and stores it in a database as well.","title":"What events do the indexer listen to?"},{"location":"overview/indexer/#multichain-abstraction","text":"In order to be able to connect differently, not EVM based blockchains together, Rarible had to create a few different blockchain indexers. They all work based on the same principle, but since different blockchains like Tezos, Solana, Flow, have different architecture, they couldn't be simply merge. But the merge could be abstracted, and that's what Rarible has done. It created a service called Union, and it works as a \"really smart proxy\" which allows you to use one API for all the blockchains. It takes all the Kafka proxy topics, from all the blockchains, and merges it into one topic. That's how you're able to get info from all the blockchains by using one Multichain API.","title":"Multichain abstraction"},{"location":"overview/lazy-minting/","text":"Lazy Minting \u00b6 In order to be able to fully understand what lazy minting is, and the benefits of doing so, we have to scratch the other aspects of blockchain and NFTs first. This document will touch three main aspects, which are crucial in a lazy minting process understanding: Technical description of NFT Minting Lazy Minting Technical description of NFT \u00b6 If you're familiar with the concept of NFTs creation, feel free to skip this section. NFT in its essence is just a variable in a Smart Contract code. The most common approach is as follows: Upload metadata (image, description, attributes, etc.) to IPFS, which is a decentralized JSON-like database. If you ever used a NoSQL database like MongoDB or Firebase, that's basically that, only decentralized. Based on all the properties you've uploaded, a hash is calculated, by which you can now access your asset. Professionally, it's called URI, which stands for Unique Resource Identifier. Moreover, since storing image data on the blockchain would be expensive, instead of image data itself, you store an image URL in your NFT. The image itself can be stored on IPFS. Just not in the JSON you use for the NFT creation. Invoke a Smart Contract function responsible for minting, and assign the URI created in the earlier step to your account address. That's it. Since the code on the blockchain is immutable, and we have a tokenId variable that tracks every unique NFT creation on a given smart contract, even if the same URI would be used twice, it will still be a different NFT. Minting \u00b6 If you've read the first point, you've already had a quite good explanation of how the minting process works. Minting can be described as a process of a write operation (it's an important fact, because if you're writing on the blockchain, you're paying a gas fee), which has one goal \u2014 associate an address of a creator with a tokenId, which points to token metadata URI on IPFS. Pardon those who thought that it is more complicated. Of course, there are some language-specific restrictions and security steps that we have to take care of, but it's enough to use OpenZeppelin implementation of ERC721/ERC1155 to safely elevate core functionality, which in this case is NFT creation. Lazy Minting \u00b6 The most important difference to point out between minting and lazy minting is writing to the blockchain action. As it was said before when writing to a blockchain occurs, the money from your wallet disappears i.e. you pay a gas fee. In a normal minting, this process takes place immediately. In a lazy mint, it can be postponed to the first transfer action (mostly it will be a buy action). How does that work under hood? There is some sort of off-chain database involved there. Basically, instead of immediately minting an NFT, the service stores its details in the off-chain database. In this way, it is able to properly display all the information like image, creator, etc. When the first buy occurs, it is then minted straight to the buyer, but keeps all the information about an author or royalties. The benefits of that are obvious \u2014 you as the creator don't pay a gas limit. You get the same functionality without any cost. You can then either lower the price of an NFT since the duty of gas payment lies on the buyer's side, or you can just get more money. The choice is yours.","title":"Lazy Minting"},{"location":"overview/lazy-minting/#lazy-minting","text":"In order to be able to fully understand what lazy minting is, and the benefits of doing so, we have to scratch the other aspects of blockchain and NFTs first. This document will touch three main aspects, which are crucial in a lazy minting process understanding: Technical description of NFT Minting Lazy Minting","title":"Lazy Minting"},{"location":"overview/lazy-minting/#technical-description-of-nft","text":"If you're familiar with the concept of NFTs creation, feel free to skip this section. NFT in its essence is just a variable in a Smart Contract code. The most common approach is as follows: Upload metadata (image, description, attributes, etc.) to IPFS, which is a decentralized JSON-like database. If you ever used a NoSQL database like MongoDB or Firebase, that's basically that, only decentralized. Based on all the properties you've uploaded, a hash is calculated, by which you can now access your asset. Professionally, it's called URI, which stands for Unique Resource Identifier. Moreover, since storing image data on the blockchain would be expensive, instead of image data itself, you store an image URL in your NFT. The image itself can be stored on IPFS. Just not in the JSON you use for the NFT creation. Invoke a Smart Contract function responsible for minting, and assign the URI created in the earlier step to your account address. That's it. Since the code on the blockchain is immutable, and we have a tokenId variable that tracks every unique NFT creation on a given smart contract, even if the same URI would be used twice, it will still be a different NFT.","title":"Technical description of NFT"},{"location":"overview/lazy-minting/#minting","text":"If you've read the first point, you've already had a quite good explanation of how the minting process works. Minting can be described as a process of a write operation (it's an important fact, because if you're writing on the blockchain, you're paying a gas fee), which has one goal \u2014 associate an address of a creator with a tokenId, which points to token metadata URI on IPFS. Pardon those who thought that it is more complicated. Of course, there are some language-specific restrictions and security steps that we have to take care of, but it's enough to use OpenZeppelin implementation of ERC721/ERC1155 to safely elevate core functionality, which in this case is NFT creation.","title":"Minting"},{"location":"overview/lazy-minting/#lazy-minting_1","text":"The most important difference to point out between minting and lazy minting is writing to the blockchain action. As it was said before when writing to a blockchain occurs, the money from your wallet disappears i.e. you pay a gas fee. In a normal minting, this process takes place immediately. In a lazy mint, it can be postponed to the first transfer action (mostly it will be a buy action). How does that work under hood? There is some sort of off-chain database involved there. Basically, instead of immediately minting an NFT, the service stores its details in the off-chain database. In this way, it is able to properly display all the information like image, creator, etc. When the first buy occurs, it is then minted straight to the buyer, but keeps all the information about an author or royalties. The benefits of that are obvious \u2014 you as the creator don't pay a gas limit. You get the same functionality without any cost. You can then either lower the price of an NFT since the duty of gas payment lies on the buyer's side, or you can just get more money. The choice is yours.","title":"Lazy Minting"},{"location":"overview/next-steps/","text":"Next Steps \u00b6 The main information about starting using Rarible Protocol Multichain SDK Quick Start Guide Reference Overview Contract Addresses Install and configurate SDK Wallets initialization Use Cases","title":"Next Steps"},{"location":"overview/next-steps/#next-steps","text":"The main information about starting using Rarible Protocol Multichain SDK Quick Start Guide Reference Overview Contract Addresses Install and configurate SDK Wallets initialization Use Cases","title":"Next Steps"},{"location":"overview/protocol-overview/","text":"Protocol Overview \u00b6 Rarible Multichain Protocol is a decentralized toolset that simplifies the way developers can work with NFTs. Protocol builds an abstraction layer for several blockchains and isolates the developer from their specifics with Multichain SDK. Rarible Multichain SDK is fully blockchain-agnostic. You can find a list of supported blockchains on our Features page. We use different environments for blockchain networks. See actual information on API Reference page. Rarible Multichain SDK enables applications to easily interact with Rarible Protocol: query, issue and trade NFTs on any blockchain supported. See more information on Reference section. Know about NFTs Rarible Multichain Protocol indexes and provides via API wide information about NFTs. The following data is accessible for developer using protocol near real time it is put into blockchain: Basic NFT information Owner Creator Metadata NFT transactions In addition to on-chain information, Rarible Multichain Protocol collects of-chain information like: Orders put for selling Bids put on NFTs Auctions information Multiple blockchains support Rarible Multichain Protocol is completely blockchain agnostic. Developers do not have to know details about a specific blockchain and can easily start with any of blockchains currently supported (see full list on Features page). Decrease entrance level for developer Rarible Multichain protocol provides easy-to-use API that can be used with: Frontend application Backend server application Mobile app on IOS/Android/Huawei platform No specific knowledge needed to start working with Rarible Multichain Protocol. Reliability and Performance Rarible Multichain Protocol provides high performance and reliable tools for developers. Smart-contracts for Rarible Multichain Protocol pass security audit before publishing. We are indexing data with small delay between it appear on a blockchain and moment when it is accessible with Protocol API, for most performant blockchains we sync data with up to 2 seconds delay from origin. Low Gas Consumption Rarible Multichain Protocol focused on optimizing usage costs for the users. For blockchains like Ethereum, where gas price is sufficient, we are doing a lot to minimize gas usage: Storing a considerable amount of up-to-date data off-chain - developers using our API to fetch NFT information do not pay the gas fee Providing Lazy-mint functionality that does not cost gas for minter Continuous smart contracts review and update, including on-chain auctions Advanced and robust tech done for you Creating the tech from scratch is complicated and time-consuming. Rarible provides access to the tools that the team has been developing for the past 1,5 years, with wide functionality and data on all the NFTs created. Monetization Rarible protocol enables arbitrary front-end fees: you can additionally monetize your creations.","title":"Overview"},{"location":"overview/protocol-overview/#protocol-overview","text":"Rarible Multichain Protocol is a decentralized toolset that simplifies the way developers can work with NFTs. Protocol builds an abstraction layer for several blockchains and isolates the developer from their specifics with Multichain SDK. Rarible Multichain SDK is fully blockchain-agnostic. You can find a list of supported blockchains on our Features page. We use different environments for blockchain networks. See actual information on API Reference page. Rarible Multichain SDK enables applications to easily interact with Rarible Protocol: query, issue and trade NFTs on any blockchain supported. See more information on Reference section. Know about NFTs Rarible Multichain Protocol indexes and provides via API wide information about NFTs. The following data is accessible for developer using protocol near real time it is put into blockchain: Basic NFT information Owner Creator Metadata NFT transactions In addition to on-chain information, Rarible Multichain Protocol collects of-chain information like: Orders put for selling Bids put on NFTs Auctions information Multiple blockchains support Rarible Multichain Protocol is completely blockchain agnostic. Developers do not have to know details about a specific blockchain and can easily start with any of blockchains currently supported (see full list on Features page). Decrease entrance level for developer Rarible Multichain protocol provides easy-to-use API that can be used with: Frontend application Backend server application Mobile app on IOS/Android/Huawei platform No specific knowledge needed to start working with Rarible Multichain Protocol. Reliability and Performance Rarible Multichain Protocol provides high performance and reliable tools for developers. Smart-contracts for Rarible Multichain Protocol pass security audit before publishing. We are indexing data with small delay between it appear on a blockchain and moment when it is accessible with Protocol API, for most performant blockchains we sync data with up to 2 seconds delay from origin. Low Gas Consumption Rarible Multichain Protocol focused on optimizing usage costs for the users. For blockchains like Ethereum, where gas price is sufficient, we are doing a lot to minimize gas usage: Storing a considerable amount of up-to-date data off-chain - developers using our API to fetch NFT information do not pay the gas fee Providing Lazy-mint functionality that does not cost gas for minter Continuous smart contracts review and update, including on-chain auctions Advanced and robust tech done for you Creating the tech from scratch is complicated and time-consuming. Rarible provides access to the tools that the team has been developing for the past 1,5 years, with wide functionality and data on all the NFTs created. Monetization Rarible protocol enables arbitrary front-end fees: you can additionally monetize your creations.","title":"Protocol Overview"},{"location":"overview/protocol-status/","text":"Protocol Status Page \u00b6 Available in Q2 2022","title":"Status"},{"location":"overview/protocol-status/#protocol-status-page","text":"Available in Q2 2022","title":"Protocol Status Page"},{"location":"overview/tokens-fees-royalties/","text":"Tokens, Fees, and Royalties \u00b6 What is NFT \u00b6 NFT means Non-Fungible Token. \u201cNon-fungible\u201d more or less means that it\u2019s unique and can\u2019t be replaced with something else. For example, a bitcoin is fungible \u2014 trade one for another bitcoin, and you\u2019ll have exactly the same thing. NFTs on the other hand are one-of-a-kind tokens that represent a unique good or asset which are non-fungible. If you traded it for a different NFT, you\u2019d have something completely different. NFTs can really be anything digital (such as drawings, music, videos, etc.), but a lot of the current excitement is around using the tech to sell digital art. Tokens \u00b6 Rarible Multichain Protocol various token types applicable for certain blockchain: Ethereum/Polygon: ERC-721 ERC-1155 Rarible user-owned contracts (ERC-721 and ERC-1155) \u2014 users deploy these contracts, only owners can mint in these Flow standard tokens FA2 (TZIP-012) for Tezos Cryptopunks A full list of supported token types could be found on Features page. All these contracts support these features: lazy mint Rarible on-chain royalties multiple creators upgradeable supports operators (who can transfer tokens on behalf of users) for the whole smart contract User-owned contracts use beacon proxies, and these contracts can be updated by Rarible DAO. Rarible common contracts can be upgraded too. Fees \u00b6 Rarible Multichain Protocol supports the following types of fees that are applicable to token operations: Protocol fees \u2014 are charged on both sides of the transaction Origin fees \u2014 set for each order. It may differ for two orders Royalties \u2014 the author of the work will receive a part of each sale Here is an example, how do we calculate fees for Ethereum for each side of the transaction: If there is ETH on any side of the transaction, it is used If there is no ETH, we check if there is an ERC-20 and use it If there is no ERC-20, check if there is an ERC-1155 and use it Otherwise, no fee will be charged. (e.g., if two ERC-721 are involved in the transaction) When computing the total amount of the asset: The protocol fee is added on top of the filled amount The fee for sending the buyer's order is also added on top If the buyer uses the ERC-20 token for payment, he must approve the calculated number of tokens. If the buyer uses ETH, they must send the calculated amount to ETH along with the transaction. Royalties \u00b6 Rarible Multichain Protocol supports two types of royalties: RoyaltiesV1 \u2014 defines an interface to query royalties from a contract. This is implemented on the standard Rarible token contracts. RoyaltiesV2 \u2014 the exchange contract interacts with the Rarible royalties implementation indirectly through a Royalty Registry. The registry checks if the NFT contract supports the expected interface, and if so, queries for the Rarible royalties array. For RoyaltiesV1, contract exposes getRoyalties method, which expects an ID as input (usually tokenId) and returns an array of accounts & basis points. RoyaltiesV2 allows for Rarible to support different royalty standards for different collections. Rarible Multichain Protocol Supports on-chain royalties. These are handled in the ExchangeV1 contract by the royalties array, which is needed to execute the mint function. This tuple is made up of two variables, fees.recipient and fees.value : fees.recipient \u2014 refers to either the item owner (by default) or an address where the royalties will be received. fees.value \u2014 the royalties percentage. By default, this value is 1000 on Rarible, which is a 10% royalties fee. This is done using basis points. More information regarding basis point can be found here.","title":"Tokens, Fees and Royalties"},{"location":"overview/tokens-fees-royalties/#tokens-fees-and-royalties","text":"","title":"Tokens, Fees, and Royalties"},{"location":"overview/tokens-fees-royalties/#what-is-nft","text":"NFT means Non-Fungible Token. \u201cNon-fungible\u201d more or less means that it\u2019s unique and can\u2019t be replaced with something else. For example, a bitcoin is fungible \u2014 trade one for another bitcoin, and you\u2019ll have exactly the same thing. NFTs on the other hand are one-of-a-kind tokens that represent a unique good or asset which are non-fungible. If you traded it for a different NFT, you\u2019d have something completely different. NFTs can really be anything digital (such as drawings, music, videos, etc.), but a lot of the current excitement is around using the tech to sell digital art.","title":"What is NFT"},{"location":"overview/tokens-fees-royalties/#tokens","text":"Rarible Multichain Protocol various token types applicable for certain blockchain: Ethereum/Polygon: ERC-721 ERC-1155 Rarible user-owned contracts (ERC-721 and ERC-1155) \u2014 users deploy these contracts, only owners can mint in these Flow standard tokens FA2 (TZIP-012) for Tezos Cryptopunks A full list of supported token types could be found on Features page. All these contracts support these features: lazy mint Rarible on-chain royalties multiple creators upgradeable supports operators (who can transfer tokens on behalf of users) for the whole smart contract User-owned contracts use beacon proxies, and these contracts can be updated by Rarible DAO. Rarible common contracts can be upgraded too.","title":"Tokens"},{"location":"overview/tokens-fees-royalties/#fees","text":"Rarible Multichain Protocol supports the following types of fees that are applicable to token operations: Protocol fees \u2014 are charged on both sides of the transaction Origin fees \u2014 set for each order. It may differ for two orders Royalties \u2014 the author of the work will receive a part of each sale Here is an example, how do we calculate fees for Ethereum for each side of the transaction: If there is ETH on any side of the transaction, it is used If there is no ETH, we check if there is an ERC-20 and use it If there is no ERC-20, check if there is an ERC-1155 and use it Otherwise, no fee will be charged. (e.g., if two ERC-721 are involved in the transaction) When computing the total amount of the asset: The protocol fee is added on top of the filled amount The fee for sending the buyer's order is also added on top If the buyer uses the ERC-20 token for payment, he must approve the calculated number of tokens. If the buyer uses ETH, they must send the calculated amount to ETH along with the transaction.","title":"Fees"},{"location":"overview/tokens-fees-royalties/#royalties","text":"Rarible Multichain Protocol supports two types of royalties: RoyaltiesV1 \u2014 defines an interface to query royalties from a contract. This is implemented on the standard Rarible token contracts. RoyaltiesV2 \u2014 the exchange contract interacts with the Rarible royalties implementation indirectly through a Royalty Registry. The registry checks if the NFT contract supports the expected interface, and if so, queries for the Rarible royalties array. For RoyaltiesV1, contract exposes getRoyalties method, which expects an ID as input (usually tokenId) and returns an array of accounts & basis points. RoyaltiesV2 allows for Rarible to support different royalty standards for different collections. Rarible Multichain Protocol Supports on-chain royalties. These are handled in the ExchangeV1 contract by the royalties array, which is needed to execute the mint function. This tuple is made up of two variables, fees.recipient and fees.value : fees.recipient \u2014 refers to either the item owner (by default) or an address where the royalties will be received. fees.value \u2014 the royalties percentage. By default, this value is 1000 on Rarible, which is a 10% royalties fee. This is done using basis points. More information regarding basis point can be found here.","title":"Royalties"},{"location":"reference/bid/","text":"Create and Accept Bid \u00b6 You can Create and Accept Bids with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . Create a bid \u00b6 You can place your bid for any given NFT, even if there isn't any sell offer associated with it. It's up to the owner if they accept it or not. Use bid function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function bid ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const bidAction = await sdk . order . bid ({ itemId : toItemId ( \"<ITEM_ID>\" ), }) const bidOrderId = await bidAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , }) return bidOrderId } itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 amount \u2014 amount of NFT tokens price \u2014 price per 1 NFT in ETH currency \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.) Bid on collection \u00b6 For create bid on collection, use bidOnCollection function: import { createRaribleSdk } from \"@rarible/sdk\" import { toContractAddress , toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" //Available only for ethereum async function bidOnCollection ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const bidAction = await sdk . order . bid ({ collectionId : toContractAddress ( \"<COLLECTION_ADDRESS>\" ), }) const bidOrderId = await bidAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , //+1 hour (optional) expirationDate : new Date ( Date . now () + 60 * 60 * 1000 ), }) return bidOrderId } collectionId \u2014 your collection address, that can be already deployed . Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page ContractAddress \u2014 BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 BlockchainName \u2014 ETHEREUM , FLOW , TEZOS or POLYGON Update bid \u00b6 Similarly to updating a sell order, there is also a possibility to update a bid. It can be only higher than the original bid order price. Use bid function with updateAction : import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function bid ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const bidAction = await sdk . order . bid ({ itemId : toItemId ( \"<ITEM_ID>\" ), }) const bidOrderId = await bidAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , }) const updateAction = await sdk . order . bidUpdate ({ orderId : bidOrderId , }) //You can only increase price of bid order for security reasons //If you want to force change bid price you should cancel order await updateAction . submit ({ price : \"0.000003\" }) } Accept bid \u00b6 To accept bid, use acceptBid function: import { createRaribleSdk } from \"@rarible/sdk\" import { toOrderId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function acceptBid ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const acceptBidResponse = await sdk . order . acceptBid ({ orderId : toOrderId ( \"<BIDDER_ORDER_ID>\" ), }) const acceptBidResult = await acceptBidResponse . submit ({ amount : 1 , //optional originFees : [{ account : toUnionAddress ( \"<COMISSION_ADDRESS>\" ), //2,5% value : 250 , }], //optional payouts : [{ account : toUnionAddress ( \"<PAYOUT_ADDRESS>\" ), //5% value : 500 , }], //Set true if you want to convert received WETH/wTEZ tokens to ETH/TEZ unwrap : false , }) await acceptBidResult . wait () } originFees \u2014 value and address of the origin fees for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the fees. For example, 2,5% value is 250 payouts \u2014 value and address of the payouts for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the payouts. For example, 5% value is 500 unwrap \u2014 convert (true) received WETH/wTEZ tokens to ETH/TEZ or not (false) Accept bid on collection \u00b6 To accept bid on collection, use acceptBidOnCollection function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toOrderId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" //Available only for ethereum async function acceptBidOnCollection ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const acceptBidAction = await sdk . order . acceptBid ({ orderId : toOrderId ( \"<COLLECTION_ORDER_ID>\" ), }) //If you have one or more items from collection you should accept one item at the time const acceptBidTx = await acceptBidAction . submit ({ amount : 1 , itemId : toItemId ( \"<ACCEPTED_ITEM_ID>\" ), //Set true if you want to convert received WETH/wTEZ tokens to ETH/TEZ unwrap : false , }) await acceptBidTx . wait () } Cancel a bid \u00b6 To cancel a bid, use cancelOrder function: import { createRaribleSdk } from \"@rarible/sdk\" import { toOrderId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function cancelOrder ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const cancelTx = await sdk . order . cancel ({ orderId : toOrderId ( \"<YOUR_ORDER_ID>\" ), }) await cancelTx . wait () } orderId \u2014 Id of your order, has format ${blockchain}:${id} . For example, ETHEREUM:1234567890 Checking created bid \u00b6 To check the created bid use the getAuctionBidsById API method getAuctionBidsById Returns Bids by ID. https://api.rarible.org/v0.1/auctions/{id}/bids Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/bids/byItem?itemId=ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:18821466700545955594683918922933102928122274620066857937800231922729025011855&status=ACTIVE' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"orders\" : [ { \"id\" : \"ETHEREUM:0xce5a4beadeddeefdd91dad3092315fbba176dd5325e032dd10194a9bc60bf28c\" , \"fill\" : \"0\" , \"platform\" : \"RARIBLE\" , \"status\" : \"ACTIVE\" , \"makeStock\" : \"0.12345\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-07T06:46:06.275Z\" , \"lastUpdatedAt\" : \"2022-03-07T06:46:06.275Z\" , \"takePrice\" : \"0.12345\" , \"takePriceUsd\" : \"0.12342413889756425082\" , \"priceHistory\" : [], \"maker\" : \"ETHEREUM:0x45d5ef37dfa2a3cc91d5909fd493f1a480bba6b0\" , \"make\" : { \"type\" : { \"@type\" : \"ERC20\" , \"contract\" : \"ETHEREUM:0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea\" }, \"value\" : \"0.12345\" }, \"take\" : { \"type\" : { \"@type\" : \"ERC721_Lazy\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"18821466700545955594683918922933102928122274620066857937800231922729025011855\" , \"uri\" : \"/ipfs/QmcTxYXrcoHzi5EyoypK6PvCQxy8piZiYpFKjr75MRKp89\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x299c92988198a5965111537797cc1789a5d7e336\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x299c92988198a5965111537797cc1789a5d7e336\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xee5416f619e2efefbcf4a3cc8645ff61c298ada42a5c9c07e5ce3ed66444a937010daab240392eabad2b8e4bc95f527178c377937c25a655991532a3b2ffa9361c\" ] }, \"value\" : \"1\" }, \"salt\" : \"0x24d4f84a848a4c49df39d73961b887958598046384639c09f61d4dd85f6c5f1e\" , \"signature\" : \"0x928e0d53da390ea7e58f2d5715d0492ad4dd4cae7a7126759682b642c32e3caf7395edeb8342ebf5fc57d959c996b41079e391565cc00b5966aac7f1788bc2d11c\" , \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"ETHEREUM:0x76c5855e93bd498b6331652854c4549d34bc3a30\" , \"value\" : 250 } ] } } ] } See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Create and Accept Bid"},{"location":"reference/bid/#create-and-accept-bid","text":"You can Create and Accept Bids with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Create and Accept Bid"},{"location":"reference/bid/#create-a-bid","text":"You can place your bid for any given NFT, even if there isn't any sell offer associated with it. It's up to the owner if they accept it or not. Use bid function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function bid ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const bidAction = await sdk . order . bid ({ itemId : toItemId ( \"<ITEM_ID>\" ), }) const bidOrderId = await bidAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , }) return bidOrderId } itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 amount \u2014 amount of NFT tokens price \u2014 price per 1 NFT in ETH currency \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.)","title":"Create a bid"},{"location":"reference/bid/#bid-on-collection","text":"For create bid on collection, use bidOnCollection function: import { createRaribleSdk } from \"@rarible/sdk\" import { toContractAddress , toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" //Available only for ethereum async function bidOnCollection ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const bidAction = await sdk . order . bid ({ collectionId : toContractAddress ( \"<COLLECTION_ADDRESS>\" ), }) const bidOrderId = await bidAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , //+1 hour (optional) expirationDate : new Date ( Date . now () + 60 * 60 * 1000 ), }) return bidOrderId } collectionId \u2014 your collection address, that can be already deployed . Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page ContractAddress \u2014 BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 BlockchainName \u2014 ETHEREUM , FLOW , TEZOS or POLYGON","title":"Bid on collection"},{"location":"reference/bid/#update-bid","text":"Similarly to updating a sell order, there is also a possibility to update a bid. It can be only higher than the original bid order price. Use bid function with updateAction : import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function bid ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const bidAction = await sdk . order . bid ({ itemId : toItemId ( \"<ITEM_ID>\" ), }) const bidOrderId = await bidAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , }) const updateAction = await sdk . order . bidUpdate ({ orderId : bidOrderId , }) //You can only increase price of bid order for security reasons //If you want to force change bid price you should cancel order await updateAction . submit ({ price : \"0.000003\" }) }","title":"Update bid"},{"location":"reference/bid/#accept-bid","text":"To accept bid, use acceptBid function: import { createRaribleSdk } from \"@rarible/sdk\" import { toOrderId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function acceptBid ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const acceptBidResponse = await sdk . order . acceptBid ({ orderId : toOrderId ( \"<BIDDER_ORDER_ID>\" ), }) const acceptBidResult = await acceptBidResponse . submit ({ amount : 1 , //optional originFees : [{ account : toUnionAddress ( \"<COMISSION_ADDRESS>\" ), //2,5% value : 250 , }], //optional payouts : [{ account : toUnionAddress ( \"<PAYOUT_ADDRESS>\" ), //5% value : 500 , }], //Set true if you want to convert received WETH/wTEZ tokens to ETH/TEZ unwrap : false , }) await acceptBidResult . wait () } originFees \u2014 value and address of the origin fees for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the fees. For example, 2,5% value is 250 payouts \u2014 value and address of the payouts for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the payouts. For example, 5% value is 500 unwrap \u2014 convert (true) received WETH/wTEZ tokens to ETH/TEZ or not (false)","title":"Accept bid"},{"location":"reference/bid/#accept-bid-on-collection","text":"To accept bid on collection, use acceptBidOnCollection function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toOrderId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" //Available only for ethereum async function acceptBidOnCollection ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const acceptBidAction = await sdk . order . acceptBid ({ orderId : toOrderId ( \"<COLLECTION_ORDER_ID>\" ), }) //If you have one or more items from collection you should accept one item at the time const acceptBidTx = await acceptBidAction . submit ({ amount : 1 , itemId : toItemId ( \"<ACCEPTED_ITEM_ID>\" ), //Set true if you want to convert received WETH/wTEZ tokens to ETH/TEZ unwrap : false , }) await acceptBidTx . wait () }","title":"Accept bid on collection"},{"location":"reference/bid/#cancel-a-bid","text":"To cancel a bid, use cancelOrder function: import { createRaribleSdk } from \"@rarible/sdk\" import { toOrderId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function cancelOrder ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const cancelTx = await sdk . order . cancel ({ orderId : toOrderId ( \"<YOUR_ORDER_ID>\" ), }) await cancelTx . wait () } orderId \u2014 Id of your order, has format ${blockchain}:${id} . For example, ETHEREUM:1234567890","title":"Cancel a bid"},{"location":"reference/bid/#checking-created-bid","text":"To check the created bid use the getAuctionBidsById API method getAuctionBidsById Returns Bids by ID. https://api.rarible.org/v0.1/auctions/{id}/bids Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/bids/byItem?itemId=ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:18821466700545955594683918922933102928122274620066857937800231922729025011855&status=ACTIVE' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"orders\" : [ { \"id\" : \"ETHEREUM:0xce5a4beadeddeefdd91dad3092315fbba176dd5325e032dd10194a9bc60bf28c\" , \"fill\" : \"0\" , \"platform\" : \"RARIBLE\" , \"status\" : \"ACTIVE\" , \"makeStock\" : \"0.12345\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-07T06:46:06.275Z\" , \"lastUpdatedAt\" : \"2022-03-07T06:46:06.275Z\" , \"takePrice\" : \"0.12345\" , \"takePriceUsd\" : \"0.12342413889756425082\" , \"priceHistory\" : [], \"maker\" : \"ETHEREUM:0x45d5ef37dfa2a3cc91d5909fd493f1a480bba6b0\" , \"make\" : { \"type\" : { \"@type\" : \"ERC20\" , \"contract\" : \"ETHEREUM:0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea\" }, \"value\" : \"0.12345\" }, \"take\" : { \"type\" : { \"@type\" : \"ERC721_Lazy\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"18821466700545955594683918922933102928122274620066857937800231922729025011855\" , \"uri\" : \"/ipfs/QmcTxYXrcoHzi5EyoypK6PvCQxy8piZiYpFKjr75MRKp89\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x299c92988198a5965111537797cc1789a5d7e336\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x299c92988198a5965111537797cc1789a5d7e336\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xee5416f619e2efefbcf4a3cc8645ff61c298ada42a5c9c07e5ce3ed66444a937010daab240392eabad2b8e4bc95f527178c377937c25a655991532a3b2ffa9361c\" ] }, \"value\" : \"1\" }, \"salt\" : \"0x24d4f84a848a4c49df39d73961b887958598046384639c09f61d4dd85f6c5f1e\" , \"signature\" : \"0x928e0d53da390ea7e58f2d5715d0492ad4dd4cae7a7126759682b642c32e3caf7395edeb8342ebf5fc57d959c996b41079e391565cc00b5966aac7f1788bc2d11c\" , \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"ETHEREUM:0x76c5855e93bd498b6331652854c4549d34bc3a30\" , \"value\" : 250 } ] } } ] } See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Checking created bid"},{"location":"reference/burn/","text":"Burn \u00b6 You can burn NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . Burn NFTs \u00b6 Burning tokens is equivalent to sending them to address 0x0 because nobody has a private key for that. Use burn function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function burn ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const burnAction = await sdk . nft . burn ({ itemId : toItemId ( \"<ITEM_ID>\" ), }) const burnTx = await burnAction . submit ({ amount : 1 , //optional creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], }) //transaction returned if item is on-chain if ( burnTx ) { await burnTx . wait () } } itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 amount \u2014 amount of NFT tokens creators \u2014 value and address of the creator account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the part in the ownership of the item. For example, 100% value is 10000 . If there are several owners, the total cost cannot be more than 10000 Checking burned NFT \u00b6 To check the burned item: Use the getItemById API method getItemById Returns Item by ID. https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Burn"},{"location":"reference/burn/#burn","text":"You can burn NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Burn"},{"location":"reference/burn/#burn-nfts","text":"Burning tokens is equivalent to sending them to address 0x0 because nobody has a private key for that. Use burn function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function burn ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const burnAction = await sdk . nft . burn ({ itemId : toItemId ( \"<ITEM_ID>\" ), }) const burnTx = await burnAction . submit ({ amount : 1 , //optional creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], }) //transaction returned if item is on-chain if ( burnTx ) { await burnTx . wait () } } itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 amount \u2014 amount of NFT tokens creators \u2014 value and address of the creator account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the part in the ownership of the item. For example, 100% value is 10000 . If there are several owners, the total cost cannot be more than 10000","title":"Burn NFTs"},{"location":"reference/burn/#checking-burned-nft","text":"To check the burned item: Use the getItemById API method getItemById Returns Item by ID. https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Checking burned NFT"},{"location":"reference/contract-addresses/","text":"Contract Addresses \u00b6 Here you can find Rarible Smart Contracts deployed instances across Mainnet, Testnet and Development. Mainnet \u00b6 Contract Addresses Mainnet Ethereum Asset Contract ERC-721 0xF6793dA657495ffeFF9Ee6350824910Abc21356C Asset Contract ERC-1155 0xB66a603f4cFe17e3D27B87a8BfCaD319856518B8 Exchange Contract 0x9757F2d2b135150BBeb65308D4a91804107cd8D6 External Royalties 0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD NFT Transfer Proxy (for Approvals) 0x4fee7b061c97c9c496b01dbce9cdb10c02f0a0be ERC-721 Token Factory 0x6E42262978de5233C8d5B05B128C121fBa110DA4 ERC-1155 Token Factory 0xDA5BFe0bD4443d63833C8f4E3284357299eaE6BC Flow RaribleNFT A.01ab36aaf654a13e.RaribleNFT RaribleOrder A.01ab36aaf654a13e.RaribleOrder RaribleFee A.336405ad2f289b87.RaribleFee LicensedNFT A.01ab36aaf654a13e.LicensedNFT Tezos Rarible public collection KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS royalties KT1HNNrmCk1fpqveRDz8Fvww2GM4gPzmA7fo transfer_proxy KT1N2oby9tYmv5tjkGD1KyVzkDRCmgDkXgSD transfer_manager KT1HTmwHGvxYgACDr1oJhMNZGzxHCAnNHaHi fill KT1D2fZiUNo6RPj3zKofH8DqDDgoV7KoyEbb exchange KT198mqFKkiWerXLmMCw69YB1i6yzYtmGVrC Polygon Exchange 0x835131b455778559CFdDd358eA3Fc762728F4E3e Transfer Proxies 0xd47e14DD9b98411754f722B4c4074e14752Ada7C ERC-721 Token Factory 0x16911a36a56f828f17632cD4915614Dd5c7a45e0 ERC-1155 Token Factory 0xF46e8e6fA0F048DdD76F8c6982eBD059796298B8 Testnet \u00b6 Contract Addresses Testnet (Rinkeby, Mumbai) Ethereum Asset Contract ERC-721 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 Asset Contract ERC-1155 0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7 Exchange Contract 0xd4a57a3bD3657D0d46B4C5bAC12b3F156B9B886b External Royalties 0xdA8e7D4cF7BA4D5912a68c1e40d3D89828fA6EE8 NFT Transfer Proxy (for Approvals) 0x7d47126a2600E22eab9eD6CF0e515678727779A6 ERC-721 Token Factory 0x62e0BDC23435321adFf249d6f41e11AEee6486Cf ERC-1155 Token Factory 0xB1Bcf905495AFf06e854904d7b2d6647ab00Cd1d Flow RaribleNFT A.ebf4ae01d1284af8.RaribleNFT RaribleOrder A.ebf4ae01d1284af8.RaribleOrder RaribleFee A.ebf4ae01d1284af8.RaribleFee LicensedNFT A.ebf4ae01d1284af8.LicensedNFT Polygon Exchange 0x4F05968D804902dd827Dd0F4fB37Ccc3071C4Bb5 Transfer Proxies 0x02e21199D043dab90248f79d6A8d0c36832734B0 ERC-721 Token Factory 0xa85180a21786bA65b0778bE1cb5CBA5E5c6cD21d ERC-1155 Token Factory 0xAa9CD5834E0009902EeAA3FEfAc6A160e9A096b4 Development \u00b6 Contract Addresses Development (Ropsten, Mumbai, Ithaca) Ethereum Asset Contract ERC-721 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 Asset Contract ERC-1155 0x6a94aC200342AC823F909F142a65232E2f052183 Exchange Contract 0x33Aef288C093Bf7b36fBe15c3190e616a993b0AD External Royalties 0x1747757768Ff4AA61390B1ed3AA019141605717B NFT Transfer Proxy (for Approvals) 0xf8e4ecac18b65fd04569ff1f0d561f74effaa206 ERC-721 Token Factory 0x939d0308CE4274C287E7305D381B336B77dBfcd3 ERC-1155 Token Factory 0xccf0cB91Fe5cCb697781427C141ed0662aE4FE2e Flow RaribleNFT A.ebf4ae01d1284af8.RaribleNFT RaribleOrder A.ebf4ae01d1284af8.RaribleOrder RaribleFee A.ebf4ae01d1284af8.RaribleFee LicensedNFT A.ebf4ae01d1284af8.LicensedNFT Tezos royalties KT1AZfqFGFLMUrscNFyawDYAyqXYydz714ya transfer_proxy KT1WbVjXdmBpzzVoYSSUiNt6QFnSC3W768d1 transfer_manager KT1L1WfmvjQRTRqT8Zv4qey4vdZbyML43UT4 fill KT1JtTi6qP5jxks3S12Uq28etuhgJCQ4tXtP exchange KT1S6H2FWxrpaD7aPRSW1cTTE1xPucXBSTL5 nft KT1ANmrMfq6SfPe2b59JGVu2CDacoaoL6hW8 Polygon Exchange 0x4F05968D804902dd827Dd0F4fB37Ccc3071C4Bb5 Transfer Proxies 0x02e21199D043dab90248f79d6A8d0c36832734B0 ERC-721 Token Factory 0xa85180a21786bA65b0778bE1cb5CBA5E5c6cD21d ERC-1155 Token Factory 0xAa9CD5834E0009902EeAA3FEfAc6A160e9A096b4","title":"Contract Addresses"},{"location":"reference/contract-addresses/#contract-addresses","text":"Here you can find Rarible Smart Contracts deployed instances across Mainnet, Testnet and Development.","title":"Contract Addresses"},{"location":"reference/contract-addresses/#mainnet","text":"Contract Addresses Mainnet Ethereum Asset Contract ERC-721 0xF6793dA657495ffeFF9Ee6350824910Abc21356C Asset Contract ERC-1155 0xB66a603f4cFe17e3D27B87a8BfCaD319856518B8 Exchange Contract 0x9757F2d2b135150BBeb65308D4a91804107cd8D6 External Royalties 0xEa90CFad1b8e030B8Fd3E63D22074E0AEb8E0DCD NFT Transfer Proxy (for Approvals) 0x4fee7b061c97c9c496b01dbce9cdb10c02f0a0be ERC-721 Token Factory 0x6E42262978de5233C8d5B05B128C121fBa110DA4 ERC-1155 Token Factory 0xDA5BFe0bD4443d63833C8f4E3284357299eaE6BC Flow RaribleNFT A.01ab36aaf654a13e.RaribleNFT RaribleOrder A.01ab36aaf654a13e.RaribleOrder RaribleFee A.336405ad2f289b87.RaribleFee LicensedNFT A.01ab36aaf654a13e.LicensedNFT Tezos Rarible public collection KT18pVpRXKPY2c4U2yFEGSH3ZnhB2kL8kwXS royalties KT1HNNrmCk1fpqveRDz8Fvww2GM4gPzmA7fo transfer_proxy KT1N2oby9tYmv5tjkGD1KyVzkDRCmgDkXgSD transfer_manager KT1HTmwHGvxYgACDr1oJhMNZGzxHCAnNHaHi fill KT1D2fZiUNo6RPj3zKofH8DqDDgoV7KoyEbb exchange KT198mqFKkiWerXLmMCw69YB1i6yzYtmGVrC Polygon Exchange 0x835131b455778559CFdDd358eA3Fc762728F4E3e Transfer Proxies 0xd47e14DD9b98411754f722B4c4074e14752Ada7C ERC-721 Token Factory 0x16911a36a56f828f17632cD4915614Dd5c7a45e0 ERC-1155 Token Factory 0xF46e8e6fA0F048DdD76F8c6982eBD059796298B8","title":"Mainnet"},{"location":"reference/contract-addresses/#testnet","text":"Contract Addresses Testnet (Rinkeby, Mumbai) Ethereum Asset Contract ERC-721 0x6ede7f3c26975aad32a475e1021d8f6f39c89d82 Asset Contract ERC-1155 0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7 Exchange Contract 0xd4a57a3bD3657D0d46B4C5bAC12b3F156B9B886b External Royalties 0xdA8e7D4cF7BA4D5912a68c1e40d3D89828fA6EE8 NFT Transfer Proxy (for Approvals) 0x7d47126a2600E22eab9eD6CF0e515678727779A6 ERC-721 Token Factory 0x62e0BDC23435321adFf249d6f41e11AEee6486Cf ERC-1155 Token Factory 0xB1Bcf905495AFf06e854904d7b2d6647ab00Cd1d Flow RaribleNFT A.ebf4ae01d1284af8.RaribleNFT RaribleOrder A.ebf4ae01d1284af8.RaribleOrder RaribleFee A.ebf4ae01d1284af8.RaribleFee LicensedNFT A.ebf4ae01d1284af8.LicensedNFT Polygon Exchange 0x4F05968D804902dd827Dd0F4fB37Ccc3071C4Bb5 Transfer Proxies 0x02e21199D043dab90248f79d6A8d0c36832734B0 ERC-721 Token Factory 0xa85180a21786bA65b0778bE1cb5CBA5E5c6cD21d ERC-1155 Token Factory 0xAa9CD5834E0009902EeAA3FEfAc6A160e9A096b4","title":"Testnet"},{"location":"reference/contract-addresses/#development","text":"Contract Addresses Development (Ropsten, Mumbai, Ithaca) Ethereum Asset Contract ERC-721 0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 Asset Contract ERC-1155 0x6a94aC200342AC823F909F142a65232E2f052183 Exchange Contract 0x33Aef288C093Bf7b36fBe15c3190e616a993b0AD External Royalties 0x1747757768Ff4AA61390B1ed3AA019141605717B NFT Transfer Proxy (for Approvals) 0xf8e4ecac18b65fd04569ff1f0d561f74effaa206 ERC-721 Token Factory 0x939d0308CE4274C287E7305D381B336B77dBfcd3 ERC-1155 Token Factory 0xccf0cB91Fe5cCb697781427C141ed0662aE4FE2e Flow RaribleNFT A.ebf4ae01d1284af8.RaribleNFT RaribleOrder A.ebf4ae01d1284af8.RaribleOrder RaribleFee A.ebf4ae01d1284af8.RaribleFee LicensedNFT A.ebf4ae01d1284af8.LicensedNFT Tezos royalties KT1AZfqFGFLMUrscNFyawDYAyqXYydz714ya transfer_proxy KT1WbVjXdmBpzzVoYSSUiNt6QFnSC3W768d1 transfer_manager KT1L1WfmvjQRTRqT8Zv4qey4vdZbyML43UT4 fill KT1JtTi6qP5jxks3S12Uq28etuhgJCQ4tXtP exchange KT1S6H2FWxrpaD7aPRSW1cTTE1xPucXBSTL5 nft KT1ANmrMfq6SfPe2b59JGVu2CDacoaoL6hW8 Polygon Exchange 0x4F05968D804902dd827Dd0F4fB37Ccc3071C4Bb5 Transfer Proxies 0x02e21199D043dab90248f79d6A8d0c36832734B0 ERC-721 Token Factory 0xa85180a21786bA65b0778bE1cb5CBA5E5c6cD21d ERC-1155 Token Factory 0xAa9CD5834E0009902EeAA3FEfAc6A160e9A096b4","title":"Development"},{"location":"reference/conversion/","text":"Convert to/from wrapped fungible tokens \u00b6 To convert to/from wrapped fungible tokens, for example, ETH to WETH, use sdk.balances.convert function: import { Blockchain } from \"@rarible/api-client\" //Convert 0.1 ETH to 0.1 wETH (Wrapped Ether) const tx = await sdk . balances . convert ( Blockchain . ETHEREUM , true , \"0.1\" ) await tx . wait () //Or unwrap 0.1 wETH to 0.1 ETH const tx = await sdk . balances . convert ( Blockchain . ETHEREUM , false , \"0.1\" ) await tx . wait ()","title":"Conversion"},{"location":"reference/conversion/#convert-tofrom-wrapped-fungible-tokens","text":"To convert to/from wrapped fungible tokens, for example, ETH to WETH, use sdk.balances.convert function: import { Blockchain } from \"@rarible/api-client\" //Convert 0.1 ETH to 0.1 wETH (Wrapped Ether) const tx = await sdk . balances . convert ( Blockchain . ETHEREUM , true , \"0.1\" ) await tx . wait () //Or unwrap 0.1 wETH to 0.1 ETH const tx = await sdk . balances . convert ( Blockchain . ETHEREUM , false , \"0.1\" ) await tx . wait ()","title":"Convert to/from wrapped fungible tokens"},{"location":"reference/create-collection/","text":"Collection \u00b6 You can Create NFT Collection with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . Create collection \u00b6 Use createCollection function: import { createRaribleSdk } from \"@rarible/sdk\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { CreateCollectionRequest } from \"@rarible/sdk/src/types/nft/deploy/domain\" async function createCollection ( wallet : BlockchainWallet , collectionRequest : CreateCollectionRequest ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const result = await sdk . nft . createCollection ( collectionRequest ) await result . tx . wait () return result . address } Depending on blockchain type, in collectionRequest should pass the following parameters: Ethereum const ethereumRequest : CreateCollectionRequest = { blockchain : Blockchain.ETHEREUM , asset : { assetType : \"ERC721\" , arguments : { name : \"name\" , symbol : \"RARI\" , baseURI : \"https://ipfs.rarible.com\" , contractURI : \"https://ipfs.rarible.com\" , isUserToken : false , }, }, } Tezos const tezosRequest : CreateCollectionRequest = { blockchain : Blockchain.TEZOS , asset : { assetType : \"NFT\" , arguments : { name : \"My NFT collection\" , symbol : \"MYNFT\" , contractURI : \"https://ipfs.io/ipfs/QmTKxwnqqxTxH4HE3UVM9yoJFZgbsZ8CuqqRFZCSWBF53m\" , isUserToken : false , }, }, } blockchain \u2014 blockchain type: ETHEREUM or TEZOS assetType \u2014 NFT collection type: ERC721 or ERC1155 for ETHEREUM , NFT or MT for TEZOS name \u2014 name of the collection symbol \u2014 symbol of the collection baseURI \u2014 prefix of the result of the tokenURI call contractURI \u2014 URI meta of the entire collection isUserToken \u2014 privat (true) or public (false) collection Checking created collection \u00b6 To check the created collection: Use the getCollectionById API method getCollectionById Returns collection by address. https://api.rarible.org/v0.1/collections/{collection} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/all?blockchains=ETHEREUM&size=3' Example response (status 200) { \"total\" : 3 , \"continuation\" : \"ETHEREUM:0x6ea0adbc173c7e8ca64c1ce881c1cfc161927876\" , \"collections\" : [ { \"id\" : \"ETHEREUM:0x6ea0adbc173c7e8ca64c1ce881c1cfc161927876\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"CryptoKitties\" , \"symbol\" : \"CK\" , \"features\" : [], \"minters\" : [] }, { \"id\" : \"ETHEREUM:0xaf2584a8b198f5d0b360b95d92aec852f7902e52\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"CRYPTO_PUNKS\" , \"name\" : \"CRYPTOPUNKS\" , \"symbol\" : \"(\u03fe)\" , \"owner\" : \"ETHEREUM:0xfb571f9da71d1ac33e069571bf5c67fadcff18e4\" , \"features\" : [], \"minters\" : [] }, { \"id\" : \"ETHEREUM:0xd0200fa0a9c94484c7152813313b122e31bed99d\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"CryptoKitties\" , \"symbol\" : \"CK\" , \"features\" : [], \"minters\" : [] } ] } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Create collection"},{"location":"reference/create-collection/#collection","text":"You can Create NFT Collection with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Collection"},{"location":"reference/create-collection/#create-collection","text":"Use createCollection function: import { createRaribleSdk } from \"@rarible/sdk\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { CreateCollectionRequest } from \"@rarible/sdk/src/types/nft/deploy/domain\" async function createCollection ( wallet : BlockchainWallet , collectionRequest : CreateCollectionRequest ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const result = await sdk . nft . createCollection ( collectionRequest ) await result . tx . wait () return result . address } Depending on blockchain type, in collectionRequest should pass the following parameters: Ethereum const ethereumRequest : CreateCollectionRequest = { blockchain : Blockchain.ETHEREUM , asset : { assetType : \"ERC721\" , arguments : { name : \"name\" , symbol : \"RARI\" , baseURI : \"https://ipfs.rarible.com\" , contractURI : \"https://ipfs.rarible.com\" , isUserToken : false , }, }, } Tezos const tezosRequest : CreateCollectionRequest = { blockchain : Blockchain.TEZOS , asset : { assetType : \"NFT\" , arguments : { name : \"My NFT collection\" , symbol : \"MYNFT\" , contractURI : \"https://ipfs.io/ipfs/QmTKxwnqqxTxH4HE3UVM9yoJFZgbsZ8CuqqRFZCSWBF53m\" , isUserToken : false , }, }, } blockchain \u2014 blockchain type: ETHEREUM or TEZOS assetType \u2014 NFT collection type: ERC721 or ERC1155 for ETHEREUM , NFT or MT for TEZOS name \u2014 name of the collection symbol \u2014 symbol of the collection baseURI \u2014 prefix of the result of the tokenURI call contractURI \u2014 URI meta of the entire collection isUserToken \u2014 privat (true) or public (false) collection","title":"Create collection"},{"location":"reference/create-collection/#checking-created-collection","text":"To check the created collection: Use the getCollectionById API method getCollectionById Returns collection by address. https://api.rarible.org/v0.1/collections/{collection} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/all?blockchains=ETHEREUM&size=3' Example response (status 200) { \"total\" : 3 , \"continuation\" : \"ETHEREUM:0x6ea0adbc173c7e8ca64c1ce881c1cfc161927876\" , \"collections\" : [ { \"id\" : \"ETHEREUM:0x6ea0adbc173c7e8ca64c1ce881c1cfc161927876\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"CryptoKitties\" , \"symbol\" : \"CK\" , \"features\" : [], \"minters\" : [] }, { \"id\" : \"ETHEREUM:0xaf2584a8b198f5d0b360b95d92aec852f7902e52\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"CRYPTO_PUNKS\" , \"name\" : \"CRYPTOPUNKS\" , \"symbol\" : \"(\u03fe)\" , \"owner\" : \"ETHEREUM:0xfb571f9da71d1ac33e069571bf5c67fadcff18e4\" , \"features\" : [], \"minters\" : [] }, { \"id\" : \"ETHEREUM:0xd0200fa0a9c94484c7152813313b122e31bed99d\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"CryptoKitties\" , \"symbol\" : \"CK\" , \"features\" : [], \"minters\" : [] } ] } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Checking created collection"},{"location":"reference/get-balance/","text":"Get balance \u00b6 You can transfer NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . To get balance of your wallet, use getBalance function: import { createRaribleSdk } from \"@rarible/sdk\" import { toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { AssetType } from \"@rarible/api-client\" async function getBalance ( wallet : BlockchainWallet , assetType : AssetType ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const balance = await sdk . balances . getBalance ( toUnionAddress ( \"<YOUR_WALLET_ADDRESS>\" ), assetType ) return balance } For getting balance from Polygon: Matic const balance = await sdk . balances . getBalance ( toUnionAddress ( \"ETHEREUM:0xc8f35463Ea36aEE234fe7EFB86373A78BF37e2A1\" ), { \"@type\" : \"ETH\" , blockchain : Blockchain.POLYGON , }) ERC20 const balance = await sdk . balances . getBalance ( toUnionAddress ( \"ETHEREUM:0xc8f35463Ea36aEE234fe7EFB86373A78BF37e2A1\" ), { \"@type\" : \"ERC20\" , contract : toContractAddress ( \"POLYGON:0xa6fa4fb5f76172d178d61b04b0ecd319c5d1c0aa\" ), })","title":"Get balance"},{"location":"reference/get-balance/#get-balance","text":"You can transfer NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . To get balance of your wallet, use getBalance function: import { createRaribleSdk } from \"@rarible/sdk\" import { toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { AssetType } from \"@rarible/api-client\" async function getBalance ( wallet : BlockchainWallet , assetType : AssetType ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const balance = await sdk . balances . getBalance ( toUnionAddress ( \"<YOUR_WALLET_ADDRESS>\" ), assetType ) return balance } For getting balance from Polygon: Matic const balance = await sdk . balances . getBalance ( toUnionAddress ( \"ETHEREUM:0xc8f35463Ea36aEE234fe7EFB86373A78BF37e2A1\" ), { \"@type\" : \"ETH\" , blockchain : Blockchain.POLYGON , }) ERC20 const balance = await sdk . balances . getBalance ( toUnionAddress ( \"ETHEREUM:0xc8f35463Ea36aEE234fe7EFB86373A78BF37e2A1\" ), { \"@type\" : \"ERC20\" , contract : toContractAddress ( \"POLYGON:0xa6fa4fb5f76172d178d61b04b0ecd319c5d1c0aa\" ), })","title":"Get balance"},{"location":"reference/install-sdk/","text":"Install Rarible SDK \u00b6 yarn add @rarible/sdk -D yarn add web3@1.5.0 yarn add tslib@2.3.1 If you need to initialize the wallets with ethers, you can install it like this: yarn add ethers To make sure the SDK is installed correctly, check version: npm view @rarible/sdk version Initialize wallets \u00b6 To use SDK, you have to create a Wallet \u2014 abstraction to communicate with real blockchain wallets. Read more about initializing wallets on Wallets page. Using SDK on client application \u00b6 SDK is written in TypeScript. You can use typings to explore SDK possibilities. import { createRaribleSdk } from \"@rarible/sdk\" Using SDK on server application \u00b6 The SDK was designed for use on the frontend side. To use the SDK on the server side (backend): Install packages: yarn add tslib@2.3.1 yarn add form-data yarn add node-fetch Add dependencies: global . FormData = require ( \"form-data\" ) global . window = { fetch : require ( \"node-fetch\" ), dispatchEvent : () => { }, } global . CustomEvent = function CustomEvent () { return } Try our example to buy Ethereum NFT item on Rinkeby network. Pass private key, node RPC URL, network ID, item ID for buyout and start: ETH_PRIVATE_KEY = \"0x...\" \\ ETHEREUM_RPC_URL = \"https://rinkeby.infura.io/...\" \\ ETHEREUM_NETWORK_ID = \"4\" \\ BUYOUT_ITEM_ID = \"0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7:102581254137174039089845694331937600507918590364933200920056519678660477714440\" \\ ts-node packages/sdk/example/backend/buy.ts","title":"Installation"},{"location":"reference/install-sdk/#install-rarible-sdk","text":"yarn add @rarible/sdk -D yarn add web3@1.5.0 yarn add tslib@2.3.1 If you need to initialize the wallets with ethers, you can install it like this: yarn add ethers To make sure the SDK is installed correctly, check version: npm view @rarible/sdk version","title":"Install Rarible SDK"},{"location":"reference/install-sdk/#initialize-wallets","text":"To use SDK, you have to create a Wallet \u2014 abstraction to communicate with real blockchain wallets. Read more about initializing wallets on Wallets page.","title":"Initialize wallets"},{"location":"reference/install-sdk/#using-sdk-on-client-application","text":"SDK is written in TypeScript. You can use typings to explore SDK possibilities. import { createRaribleSdk } from \"@rarible/sdk\"","title":"Using SDK on client application"},{"location":"reference/install-sdk/#using-sdk-on-server-application","text":"The SDK was designed for use on the frontend side. To use the SDK on the server side (backend): Install packages: yarn add tslib@2.3.1 yarn add form-data yarn add node-fetch Add dependencies: global . FormData = require ( \"form-data\" ) global . window = { fetch : require ( \"node-fetch\" ), dispatchEvent : () => { }, } global . CustomEvent = function CustomEvent () { return } Try our example to buy Ethereum NFT item on Rinkeby network. Pass private key, node RPC URL, network ID, item ID for buyout and start: ETH_PRIVATE_KEY = \"0x...\" \\ ETHEREUM_RPC_URL = \"https://rinkeby.infura.io/...\" \\ ETHEREUM_NETWORK_ID = \"4\" \\ BUYOUT_ITEM_ID = \"0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7:102581254137174039089845694331937600507918590364933200920056519678660477714440\" \\ ts-node packages/sdk/example/backend/buy.ts","title":"Using SDK on server application"},{"location":"reference/mint-and-sell/","text":"Mint and Sell \u00b6 You can prepare Mint and put up on Sale NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . Mint and List NFT for sale \u00b6 Often required to put your NFT on the sale right after creation. If it's the case for you, you can also use the mintOnChain function with sellAction : import { createRaribleSdk } from \"@rarible/sdk\" import { toContractAddress , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function mintAndSell ( wallet : BlockchainWallet , currency : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const mintAction = await sdk . nft . mintAndSell ({ collectionId : toContractAddress ( \"<NFT_CONTRACT_ADDRESS>\" ), }) /* You should upload json file with item metadata in the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : true , supply : 1 , price : \"0.000000000000000001\" , currency , }) if ( mintResult . type === MintType . OFF_CHAIN ) { return mintResult . itemId } } collectionId \u2014 your collection address, that can be already deployed . Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page ContractAddress \u2014 BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 BlockchainName \u2014 ETHEREUM , FLOW , TEZOS or POLYGON uri \u2014 address of JSON file with \"image\", \"name\" and other NFT attributes. For example, on IPFS: https://ipfs.io/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp royalties \u2014 value and address for receiving royalties account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the royalties. For example, 2,5% value is 250 creators \u2014 value and address of the creator account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the royalties. For example, 2,5% value is 250 lazyMint \u2014 boolean, false if you want to mint item on the blockchain, true allow to you mint off-chain item without spending the gas supply \u2014 number of NFTs to create (not in every case it is supported, you can check it by reading sdk.nft.mint response under multiple parameters) price \u2014 price per 1 NFT in ETH currency \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.) Update listed token price \u00b6 Due to security circumstances, you can't update the token price to higher than the one created in the original sell order. If you want to boost the price, you need to cancel the sell order and create a new one. For update listed NFT price use the sellAndUpdate function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function sellAndUpdate ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const sellAction = await sdk . order . sell ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const sellOrderId = await sellAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , }) const updateAction = await sdk . order . sellUpdate ({ orderId : sellOrderId }) //You can only decrease price of sell order for security reasons //If you want to force change sell price you should cancel sell order await updateAction . submit ({ price : \"0.000001\" }) } Checking created order \u00b6 To check the created order use the getOrderById API method getOrderById Returns Order by ID. https://api.rarible.org/v0.1/orders/{id} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed' Request parameters: id \u2014 ID of your order, has format ${blockchain}:${id} For example, ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed Example response (status 200) { \"id\" : \"ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed\" , \"fill\" : \"0.00001\" , \"platform\" : \"RARIBLE\" , \"status\" : \"FILLED\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-11T12:09:14.904Z\" , \"lastUpdatedAt\" : \"2022-03-11T12:17:21Z\" , \"makePrice\" : \"0.00001\" , \"makePriceUsd\" : \"0.026062773565248403\" , \"priceHistory\" : [ { \"date\" : \"2022-03-11T12:09:14.904Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.00001\" } ], \"maker\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155_Lazy\" , \"contract\" : \"ETHEREUM:0x4ff5fedb430f7393c8c5675e753782b595feb471\" , \"tokenId\" : \"19906957776073516298368660511705840565672843874722253325423575352615771308035\" , \"uri\" : \"https://shopdefi.gq/api/metadata/c13249c9-e99b-43cd-8a2f-9da5cd26881c\" , \"supply\" : \"1\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xee347802d66c1231e3b799dd35768d52df1cd0b8fac88675836c0b8c9394077302d45f29a1e1be7afcf7bd2a9e54cd235a8b632772228fb4cbd0ce013ac3cef71b\" ] }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.00001\" }, \"salt\" : \"0xaea6697bb08038f1ee23254fef19181bab3694464b612fb6e527ecf85f4cb830\" , \"signature\" : \"0xa80eb9c4cbea283976ba4b0db925dae0aefb2d5d4dfedbaa4214ae99a2e5832552e41634ff998b558c258f8b8bd803681534c340029cd1478292ea3838d069791c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [] } } See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Mint and Sell"},{"location":"reference/mint-and-sell/#mint-and-sell","text":"You can prepare Mint and put up on Sale NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Mint and Sell"},{"location":"reference/mint-and-sell/#mint-and-list-nft-for-sale","text":"Often required to put your NFT on the sale right after creation. If it's the case for you, you can also use the mintOnChain function with sellAction : import { createRaribleSdk } from \"@rarible/sdk\" import { toContractAddress , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function mintAndSell ( wallet : BlockchainWallet , currency : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const mintAction = await sdk . nft . mintAndSell ({ collectionId : toContractAddress ( \"<NFT_CONTRACT_ADDRESS>\" ), }) /* You should upload json file with item metadata in the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : true , supply : 1 , price : \"0.000000000000000001\" , currency , }) if ( mintResult . type === MintType . OFF_CHAIN ) { return mintResult . itemId } } collectionId \u2014 your collection address, that can be already deployed . Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page ContractAddress \u2014 BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 BlockchainName \u2014 ETHEREUM , FLOW , TEZOS or POLYGON uri \u2014 address of JSON file with \"image\", \"name\" and other NFT attributes. For example, on IPFS: https://ipfs.io/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp royalties \u2014 value and address for receiving royalties account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the royalties. For example, 2,5% value is 250 creators \u2014 value and address of the creator account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the royalties. For example, 2,5% value is 250 lazyMint \u2014 boolean, false if you want to mint item on the blockchain, true allow to you mint off-chain item without spending the gas supply \u2014 number of NFTs to create (not in every case it is supported, you can check it by reading sdk.nft.mint response under multiple parameters) price \u2014 price per 1 NFT in ETH currency \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.)","title":"Mint and List NFT for sale"},{"location":"reference/mint-and-sell/#update-listed-token-price","text":"Due to security circumstances, you can't update the token price to higher than the one created in the original sell order. If you want to boost the price, you need to cancel the sell order and create a new one. For update listed NFT price use the sellAndUpdate function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function sellAndUpdate ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const sellAction = await sdk . order . sell ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const sellOrderId = await sellAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , }) const updateAction = await sdk . order . sellUpdate ({ orderId : sellOrderId }) //You can only decrease price of sell order for security reasons //If you want to force change sell price you should cancel sell order await updateAction . submit ({ price : \"0.000001\" }) }","title":"Update listed token price"},{"location":"reference/mint-and-sell/#checking-created-order","text":"To check the created order use the getOrderById API method getOrderById Returns Order by ID. https://api.rarible.org/v0.1/orders/{id} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed' Request parameters: id \u2014 ID of your order, has format ${blockchain}:${id} For example, ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed Example response (status 200) { \"id\" : \"ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed\" , \"fill\" : \"0.00001\" , \"platform\" : \"RARIBLE\" , \"status\" : \"FILLED\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-11T12:09:14.904Z\" , \"lastUpdatedAt\" : \"2022-03-11T12:17:21Z\" , \"makePrice\" : \"0.00001\" , \"makePriceUsd\" : \"0.026062773565248403\" , \"priceHistory\" : [ { \"date\" : \"2022-03-11T12:09:14.904Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.00001\" } ], \"maker\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155_Lazy\" , \"contract\" : \"ETHEREUM:0x4ff5fedb430f7393c8c5675e753782b595feb471\" , \"tokenId\" : \"19906957776073516298368660511705840565672843874722253325423575352615771308035\" , \"uri\" : \"https://shopdefi.gq/api/metadata/c13249c9-e99b-43cd-8a2f-9da5cd26881c\" , \"supply\" : \"1\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xee347802d66c1231e3b799dd35768d52df1cd0b8fac88675836c0b8c9394077302d45f29a1e1be7afcf7bd2a9e54cd235a8b632772228fb4cbd0ce013ac3cef71b\" ] }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.00001\" }, \"salt\" : \"0xaea6697bb08038f1ee23254fef19181bab3694464b612fb6e527ecf85f4cb830\" , \"signature\" : \"0xa80eb9c4cbea283976ba4b0db925dae0aefb2d5d4dfedbaa4214ae99a2e5832552e41634ff998b558c258f8b8bd803681534c340029cd1478292ea3838d069791c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [] } } See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Checking created order"},{"location":"reference/mint/","text":"Mint \u00b6 You can Mint NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . Minting Multichain \u00b6 Lazy Minting (off-chain) \u00b6 Use mintOffChain function: import { createRaribleSdk } from \"@rarible/sdk\" import { toContractAddress , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" async function mintOffChain ( wallet : BlockchainWallet , contractAddress : string ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const mintAction = await sdk . nft . mint ({ collectionId : toContractAddress ( contractAddress ), }) /* You should upload json file with item metadata in the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : true , supply : 1 , }) if ( mintResult . type === MintType . OFF_CHAIN ) { return mintResult . itemId } } collectionId \u2014 your collection address, that can be already deployed . Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page ContractAddress \u2014 BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 BlockchainName \u2014 ETHEREUM , FLOW , TEZOS or POLYGON uri \u2014 address of JSON file with \"image\", \"name\" and other NFT attributes. For example, on IPFS: https://ipfs.io/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp royalties \u2014 value and address for receiving royalties account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the royalties. For example, 10% value is 1000 creators \u2014 value and address of the creator account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the part in the ownership of the item. For example, 100% value is 10000 . If there are several owners, the total cost cannot be more than 10000 lazyMint \u2014 boolean, false if you want to mint item on the blockchain, true allow to you mint off-chain item without spending the gas supply \u2014 number of NFTs to create (not in every case it is supported, you can check it by reading sdk.nft.mint response under multiple parameters) Example of a successful response: itemId : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382047\" ; type : \"off-chain\" itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Minting (on-chain) \u00b6 Use mintOnChain function: import { createRaribleSdk } from \"@rarible/sdk\" import { toContractAddress , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" async function mintOnChain ( wallet : BlockchainWallet , contractAddress : string ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const mintAction = await sdk . nft . mint ({ collectionId : toContractAddress ( contractAddress ), }) /* You should upload json file with item metadata in the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , //optional royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], //optional creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : false , supply : 1 , }) if ( mintResult . type === MintType . ON_CHAIN ) { await mintResult . transaction . wait () return mintResult . itemId } } Minting with tokenId \u00b6 Usually the tokenId is generated automatically. If you need to get a tokenId before, for example, you want to upload data to the IPFS, use mintOnChainWithTokenId function: import { createRaribleSdk } from \"@rarible/sdk\" import { toContractAddress , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" async function mintOnChainWithTokenId ( wallet : BlockchainWallet , contractAddress : string ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const collectionId = toContractAddress ( contractAddress ) //Get tokenId for collection and mint const tokenId = await sdk . nft . generateTokenId ({ collection : collectionId , minter : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), }) const mintAction = await sdk . nft . mint ({ collectionId , tokenId , }) /* You should upload json file with item metadata with the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , //optional royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], //optional, by default creator=minter creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : false , supply : 1 , }) if ( mintResult . type === MintType . ON_CHAIN ) { await mintResult . transaction . wait () return mintResult . itemId } } Checking created NFT \u00b6 To check the created item: Use the getItemById API method getItemById Returns Item by ID. https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. You can find more information about Mint in Rarible Protocol SDK . Or you can use it as a regular async function and work with regular Promises. Minting in specific blockchain networks \u00b6 We recommend using the Multichain Protocol for minting tokens. But you can also make Mint on a specific blockchain network. Ethereum With Rarible Protocol Ethereum SDK, you can mint and lazy mint ERC-721 and ERC-1155 NFT tokens in the Ethereum network. Mint Minting is using the mintAndTransfer function for ERC-721 and ERC-1155 contracts. For ERC-721, the function has the following signature: mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) . struct Mint721Data { uint tokenId; string tokenURI; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-721 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs://ipfs/ creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. For ERC-1155, the function has the following signature: mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) . struct Mint1155Data { uint tokenId; string tokenURI; uint supply; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-1155 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs://ipfs/ supply \u2014 total number of tokens for minting creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. Lazy Mint Lazy Minting is supported for ERC-721 and ERC-1155. Lazy mint To create Lazy Minting: Generate a token ID Create a Lazy Minting request body that the creator must sign The creator signs the provided data Add signature to the request body Send the data to the API For more information about Lazy Minting, see SDK page. Flow With Rarible Protocol Flow SDK, you can mint Flow NFT tokens. Mint response represents transaction result extended with txId and minted tokenId const { txId , // transaction id tokenId , // minted tokenId status , // flow transaction status statusCode , // flow transaction statusCode - for example: value 4 for sealed transaction errorMessage , events , // events generated from contract and include all events produced by transaction, deopsits withdrown etc. } = await sdk . nft . mint ( collection , \"your meta info\" , []) Tezos With Rarible Protocol Tezos SDK, you can mint Tezos NFT tokens. const result = await mint ( provider : Provider , contract : string , royalties : { [ key : string ] : BigNumber }, supply? : BigNumber , token_id? : BigNumber , metadata ?: { [ key : string ] : string }, owner? : string , ) See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Mint"},{"location":"reference/mint/#mint","text":"You can Mint NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Mint"},{"location":"reference/mint/#minting-multichain","text":"","title":"Minting Multichain"},{"location":"reference/mint/#lazy-minting-off-chain","text":"Use mintOffChain function: import { createRaribleSdk } from \"@rarible/sdk\" import { toContractAddress , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" async function mintOffChain ( wallet : BlockchainWallet , contractAddress : string ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const mintAction = await sdk . nft . mint ({ collectionId : toContractAddress ( contractAddress ), }) /* You should upload json file with item metadata in the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : true , supply : 1 , }) if ( mintResult . type === MintType . OFF_CHAIN ) { return mintResult . itemId } } collectionId \u2014 your collection address, that can be already deployed . Also, can be the address of Rarible Smart Contracts instance. You can find them on Contract Addresses page ContractAddress \u2014 BlockchainName:HexAddress = ETHEREUM:0xB0EA149212Eb707a1E5FC1D2d3fD318a8d94cf05 BlockchainName \u2014 ETHEREUM , FLOW , TEZOS or POLYGON uri \u2014 address of JSON file with \"image\", \"name\" and other NFT attributes. For example, on IPFS: https://ipfs.io/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp royalties \u2014 value and address for receiving royalties account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the royalties. For example, 10% value is 1000 creators \u2014 value and address of the creator account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the part in the ownership of the item. For example, 100% value is 10000 . If there are several owners, the total cost cannot be more than 10000 lazyMint \u2014 boolean, false if you want to mint item on the blockchain, true allow to you mint off-chain item without spending the gas supply \u2014 number of NFTs to create (not in every case it is supported, you can check it by reading sdk.nft.mint response under multiple parameters) Example of a successful response: itemId : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:55143609719300586327244080327388661151936544170854464635146779205246455382047\" ; type : \"off-chain\" itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345","title":"Lazy Minting (off-chain)"},{"location":"reference/mint/#minting-on-chain","text":"Use mintOnChain function: import { createRaribleSdk } from \"@rarible/sdk\" import { toContractAddress , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" async function mintOnChain ( wallet : BlockchainWallet , contractAddress : string ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const mintAction = await sdk . nft . mint ({ collectionId : toContractAddress ( contractAddress ), }) /* You should upload json file with item metadata in the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , //optional royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], //optional creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : false , supply : 1 , }) if ( mintResult . type === MintType . ON_CHAIN ) { await mintResult . transaction . wait () return mintResult . itemId } }","title":"Minting (on-chain)"},{"location":"reference/mint/#minting-with-tokenid","text":"Usually the tokenId is generated automatically. If you need to get a tokenId before, for example, you want to upload data to the IPFS, use mintOnChainWithTokenId function: import { createRaribleSdk } from \"@rarible/sdk\" import { toContractAddress , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import { MintType } from \"@rarible/sdk/build/types/nft/mint/domain\" async function mintOnChainWithTokenId ( wallet : BlockchainWallet , contractAddress : string ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const collectionId = toContractAddress ( contractAddress ) //Get tokenId for collection and mint const tokenId = await sdk . nft . generateTokenId ({ collection : collectionId , minter : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), }) const mintAction = await sdk . nft . mint ({ collectionId , tokenId , }) /* You should upload json file with item metadata with the following format: { name: string description: string | undefined image: string | undefined \"animation_url\": string | undefined \"external_url\": string | undefined attributes: TokenMetadataAttribute[] } and insert link to json file to \"uri\" field. To format your json data use \"sdk.nft.preprocessMeta()\" method */ const mintResult = await mintAction . submit ({ uri : \"<YOUR_LINK_TO_JSON>\" , //optional royalties : [{ account : toUnionAddress ( \"<ROYLATY_ADDRESS>\" ), value : 1000 , }], //optional, by default creator=minter creators : [{ account : toUnionAddress ( \"<CREATOR_ADDRESS>\" ), value : 10000 , }], lazyMint : false , supply : 1 , }) if ( mintResult . type === MintType . ON_CHAIN ) { await mintResult . transaction . wait () return mintResult . itemId } }","title":"Minting with tokenId"},{"location":"reference/mint/#checking-created-nft","text":"To check the created item: Use the getItemById API method getItemById Returns Item by ID. https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. You can find more information about Mint in Rarible Protocol SDK . Or you can use it as a regular async function and work with regular Promises.","title":"Checking created NFT"},{"location":"reference/mint/#minting-in-specific-blockchain-networks","text":"We recommend using the Multichain Protocol for minting tokens. But you can also make Mint on a specific blockchain network. Ethereum With Rarible Protocol Ethereum SDK, you can mint and lazy mint ERC-721 and ERC-1155 NFT tokens in the Ethereum network. Mint Minting is using the mintAndTransfer function for ERC-721 and ERC-1155 contracts. For ERC-721, the function has the following signature: mintAndTransfer(LibERC721LazyMint.Mint721Data memory data, address to) . struct Mint721Data { uint tokenId; string tokenURI; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-721 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs://ipfs/ creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. For ERC-1155, the function has the following signature: mintAndTransfer(LibERC1155LazyMint.Mint1155Data memory data, address to, uint256 _amount) . struct Mint1155Data { uint tokenId; string tokenURI; uint supply; address[] creators; LibPart.Part[] royalties; bytes[] signatures; } tokenId \u2014 tokenId of the ERC-1155 standard tokenURI \u2014 suffix for the token URI. The prefix is usually ipfs://ipfs/ supply \u2014 total number of tokens for minting creators \u2014 an array of authors addresses royalties \u2014 royalty array signatures \u2014 array of signatures. Each creator must have a signature. The only exception is when the creator sends a Mint transaction. Lazy Mint Lazy Minting is supported for ERC-721 and ERC-1155. Lazy mint To create Lazy Minting: Generate a token ID Create a Lazy Minting request body that the creator must sign The creator signs the provided data Add signature to the request body Send the data to the API For more information about Lazy Minting, see SDK page. Flow With Rarible Protocol Flow SDK, you can mint Flow NFT tokens. Mint response represents transaction result extended with txId and minted tokenId const { txId , // transaction id tokenId , // minted tokenId status , // flow transaction status statusCode , // flow transaction statusCode - for example: value 4 for sealed transaction errorMessage , events , // events generated from contract and include all events produced by transaction, deopsits withdrown etc. } = await sdk . nft . mint ( collection , \"your meta info\" , []) Tezos With Rarible Protocol Tezos SDK, you can mint Tezos NFT tokens. const result = await mint ( provider : Provider , contract : string , royalties : { [ key : string ] : BigNumber }, supply? : BigNumber , token_id? : BigNumber , metadata ?: { [ key : string ] : string }, owner? : string , ) See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Minting in specific blockchain networks"},{"location":"reference/order/","text":"Sell Order \u00b6 When you have your NFT created, there is a high chance that you will want to sell it. Or try, at least. You can Sell NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . List NFT for sale \u00b6 Often required to put your NFT on the sale right after creation. If it's the case for you, you can also use the mintOnChain function with sellAction : import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function mintOnChain ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const sellResponse = await sdk . order . sell ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const sellOrderId = await sellResponse . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , originFees : [{ account : toUnionAddress ( \"<COMISSION_ADDRESS>\" ), //2,5% value : 250 , }], payouts : [{ account : toUnionAddress ( \"<PAYOUT_ADDRESS>\" ), //5% value : 500 , }], //+1 hour expirationDate : new Date ( Date . now () + 60 * 60 * 1000 ), }) return sellOrderId } itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 amount \u2014 amount of NFT tokens for sale price \u2014 price per 1 NFT in ETH currency \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.) originFees \u2014 value and address of the origin fees for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the fees. For example, 2,5% value is 250 payouts \u2014 value and address of the payouts for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the payouts. For example, 5% value is 500 Update listed token price \u00b6 Due to security circumstances, you can't update the token price to higher than the one created in the original sell order. If you want to boost the price, you need to cancel the sell order and create a new one. For update listed NFT price use the sellAndUpdate function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function sellAndUpdate ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const sellAction = await sdk . order . sell ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const sellOrderId = await sellAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , originFees : [{ account : toUnionAddress ( \"<COMISSION_ADDRESS>\" ), //2,5% value : 250 , }], payouts : [{ account : toUnionAddress ( \"<PAYOUT_ADDRESS>\" ), //5% value : 500 , }], }) const updateAction = await sdk . order . sellUpdate ({ orderId : sellOrderId }) //You can only decrease price of sell order for security reasons //If you want to force change sell price you should cancel sell order await updateAction . submit ({ price : \"0.000001\" }) } Checking created order \u00b6 To check the created order use the getOrderById API method getOrderById Returns Order by ID. https://api.rarible.org/v0.1/orders/{id} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed' Request parameters: id \u2014 ID of your order, has format ${blockchain}:${id} For example, ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed Example response (status 200) { \"id\" : \"ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed\" , \"fill\" : \"0.00001\" , \"platform\" : \"RARIBLE\" , \"status\" : \"FILLED\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-11T12:09:14.904Z\" , \"lastUpdatedAt\" : \"2022-03-11T12:17:21Z\" , \"makePrice\" : \"0.00001\" , \"makePriceUsd\" : \"0.026062773565248403\" , \"priceHistory\" : [ { \"date\" : \"2022-03-11T12:09:14.904Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.00001\" } ], \"maker\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155_Lazy\" , \"contract\" : \"ETHEREUM:0x4ff5fedb430f7393c8c5675e753782b595feb471\" , \"tokenId\" : \"19906957776073516298368660511705840565672843874722253325423575352615771308035\" , \"uri\" : \"https://shopdefi.gq/api/metadata/c13249c9-e99b-43cd-8a2f-9da5cd26881c\" , \"supply\" : \"1\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xee347802d66c1231e3b799dd35768d52df1cd0b8fac88675836c0b8c9394077302d45f29a1e1be7afcf7bd2a9e54cd235a8b632772228fb4cbd0ce013ac3cef71b\" ] }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.00001\" }, \"salt\" : \"0xaea6697bb08038f1ee23254fef19181bab3694464b612fb6e527ecf85f4cb830\" , \"signature\" : \"0xa80eb9c4cbea283976ba4b0db925dae0aefb2d5d4dfedbaa4214ae99a2e5832552e41634ff998b558c258f8b8bd803681534c340029cd1478292ea3838d069791c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [] } } See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Sell Order"},{"location":"reference/order/#sell-order","text":"When you have your NFT created, there is a high chance that you will want to sell it. Or try, at least. You can Sell NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Sell Order"},{"location":"reference/order/#list-nft-for-sale","text":"Often required to put your NFT on the sale right after creation. If it's the case for you, you can also use the mintOnChain function with sellAction : import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function mintOnChain ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const sellResponse = await sdk . order . sell ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const sellOrderId = await sellResponse . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , originFees : [{ account : toUnionAddress ( \"<COMISSION_ADDRESS>\" ), //2,5% value : 250 , }], payouts : [{ account : toUnionAddress ( \"<PAYOUT_ADDRESS>\" ), //5% value : 500 , }], //+1 hour expirationDate : new Date ( Date . now () + 60 * 60 * 1000 ), }) return sellOrderId } itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 amount \u2014 amount of NFT tokens for sale price \u2014 price per 1 NFT in ETH currency \u2014 currency (ETH or specific ERC20 or Tez, Flow, etc.) originFees \u2014 value and address of the origin fees for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the fees. For example, 2,5% value is 250 payouts \u2014 value and address of the payouts for the order account \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh value \u2014 value of the payouts. For example, 5% value is 500","title":"List NFT for sale"},{"location":"reference/order/#update-listed-token-price","text":"Due to security circumstances, you can't update the token price to higher than the one created in the original sell order. If you want to boost the price, you need to cancel the sell order and create a new one. For update listed NFT price use the sellAndUpdate function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" import type { RequestCurrency } from \"@rarible/sdk/build/common/domain\" async function sellAndUpdate ( wallet : BlockchainWallet , assetType : RequestCurrency ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const sellAction = await sdk . order . sell ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const sellOrderId = await sellAction . submit ({ amount : 1 , price : \"0.000002\" , currency : assetType , originFees : [{ account : toUnionAddress ( \"<COMISSION_ADDRESS>\" ), //2,5% value : 250 , }], payouts : [{ account : toUnionAddress ( \"<PAYOUT_ADDRESS>\" ), //5% value : 500 , }], }) const updateAction = await sdk . order . sellUpdate ({ orderId : sellOrderId }) //You can only decrease price of sell order for security reasons //If you want to force change sell price you should cancel sell order await updateAction . submit ({ price : \"0.000001\" }) }","title":"Update listed token price"},{"location":"reference/order/#checking-created-order","text":"To check the created order use the getOrderById API method getOrderById Returns Order by ID. https://api.rarible.org/v0.1/orders/{id} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed' Request parameters: id \u2014 ID of your order, has format ${blockchain}:${id} For example, ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed Example response (status 200) { \"id\" : \"ETHEREUM:0x0293c5918e9f7fb5eec101a656e5ba73fcfd61072ad211a9e80972cc487232ed\" , \"fill\" : \"0.00001\" , \"platform\" : \"RARIBLE\" , \"status\" : \"FILLED\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-11T12:09:14.904Z\" , \"lastUpdatedAt\" : \"2022-03-11T12:17:21Z\" , \"makePrice\" : \"0.00001\" , \"makePriceUsd\" : \"0.026062773565248403\" , \"priceHistory\" : [ { \"date\" : \"2022-03-11T12:09:14.904Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.00001\" } ], \"maker\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155_Lazy\" , \"contract\" : \"ETHEREUM:0x4ff5fedb430f7393c8c5675e753782b595feb471\" , \"tokenId\" : \"19906957776073516298368660511705840565672843874722253325423575352615771308035\" , \"uri\" : \"https://shopdefi.gq/api/metadata/c13249c9-e99b-43cd-8a2f-9da5cd26881c\" , \"supply\" : \"1\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x2c02f0563eaf96dc3ddcb514f4d1832e7cbc801f\" , \"value\" : 1000 } ], \"signatures\" : [ \"0xee347802d66c1231e3b799dd35768d52df1cd0b8fac88675836c0b8c9394077302d45f29a1e1be7afcf7bd2a9e54cd235a8b632772228fb4cbd0ce013ac3cef71b\" ] }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.00001\" }, \"salt\" : \"0xaea6697bb08038f1ee23254fef19181bab3694464b612fb6e527ecf85f4cb830\" , \"signature\" : \"0xa80eb9c4cbea283976ba4b0db925dae0aefb2d5d4dfedbaa4214ae99a2e5832552e41634ff998b558c258f8b8bd803681534c340029cd1478292ea3838d069791c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [] } } See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Checking created order"},{"location":"reference/reference-overview/","text":"Overview \u00b6 Rarible creates Multichain SDK, an abstraction of complicated blockchain logic underneath, allowing end-users to interact with the blockchain to create some sorts of assets and list them to sell, trade, etc. In other words, Multichain SDK is ready to go, NFT marketplace functionality, which you can use out of the box. See more information about API on API Reference page. First Steps Install SDK Initialize Wallets See how to use common functionality: Create collection Mint NFT Sell NFTs Mint and Sell Create and Accept Bid Transfer tokens Burn tokens Get wallet balance Tokens conversion Check Contract Addresses and Search Capabilities","title":"Overview"},{"location":"reference/reference-overview/#overview","text":"Rarible creates Multichain SDK, an abstraction of complicated blockchain logic underneath, allowing end-users to interact with the blockchain to create some sorts of assets and list them to sell, trade, etc. In other words, Multichain SDK is ready to go, NFT marketplace functionality, which you can use out of the box. See more information about API on API Reference page. First Steps Install SDK Initialize Wallets See how to use common functionality: Create collection Mint NFT Sell NFTs Mint and Sell Create and Accept Bid Transfer tokens Burn tokens Get wallet balance Tokens conversion Check Contract Addresses and Search Capabilities","title":"Overview"},{"location":"reference/search-capabilities/","text":"Search Capabilities \u00b6 On the multichain.redoc.ly you can find main information about Protocol API. Controllers \u00b6 Use the following controllers to search information about NFT with our multichain API: Signature controller \u2014 uses for validation of the order signature Currency controller \u2014 getting currency USD rate Item controller \u2014 getting information about NFT items Ownership controller \u2014 getting information about NFT items ownership Order controller \u2014 getting information about NFT orders Auction controller \u2014 getting information about NFT auctions Activity controller \u2014 getting information about activities with NFT Collection controller \u2014 getting information about NFT collections API usage Examples \u00b6 Items \u00b6 get Item by owner Returns Item by owner https://api.rarible.org/v0.1/items/byOwner Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/byOwner?owner=ETHEREUM:0x66606fe12f319a8f781a9af35c3d061617ea642a&size=1' Request parameters: owner \u2014 address of the item owner, has format ${blockchain}:${address} . For example, ETHEREUM:0x66606fe12f319a8f781a9af35c3d061617ea642a Example response (status 200) { \"total\" : 1 , \"continuation\" : \"1648125753039_0x08295565739cf720f2a61e5237815eacfad98c6a:2102\" , \"items\" : [ { \"id\" : \"ETHEREUM:0x08295565739cf720f2a61e5237815eacfad98c6a:2102\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x08295565739cf720f2a61e5237815eacfad98c6a\" , \"contract\" : \"ETHEREUM:0x08295565739cf720f2a61e5237815eacfad98c6a\" , \"tokenId\" : \"2102\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x66606fe12f319a8f781a9af35c3d061617ea642a\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-24T12:42:33Z\" , \"lastUpdatedAt\" : \"2022-03-24T12:42:33.039Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"\u634c\uff1a\u4eba\u6d77\u832b\u832b #\\n2102\" , \"description\" : \"\u4eba\u6d77\u554a\u832b\u832b\u554a-\u300a\u6d77\u8349\u821e\u300bNFT \\n\\n\u4eba\u6d77\u554a \u832b\u832b\u554a \u968f\u6ce2\u9010\u6d41 \u6d6e\u6d6e\u6c89\u6c89\" , \"attributes\" : [ { \"key\" : \"\u6f14\u5531\" , \"value\" : \"\u8427\u5168\" }, { \"key\" : \"\u4f5c\u8bcd\" , \"value\" : \"\u8427\u5168\" }, { \"key\" : \"\u4f5c\u66f2\" , \"value\" : \"\u8427\u5168\" }, { \"key\" : \"\u7a00\u6709\u5ea6\" , \"value\" : \"\u7f55\u89c1\" } ], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmbyFuDKZc9UkxMNJ7t25cZk7mm8u77c3FENFsatxN4VNk/8.png\" , \"representation\" : \"ORIGINAL\" }, { \"@type\" : \"IMAGE\" , \"url\" : \"https://lh3.googleusercontent.com/t55AtJJ9szplBUbEchUAE_tyZuYTeSenjd7iHfVPfwsvIX3lof2kcI9jzGcpZ1Prf3oFiYLdcVsO0aFNCo-j6sgYUY0x32IEngz9s8I\" , \"representation\" : \"BIG\" }, { \"@type\" : \"IMAGE\" , \"url\" : \"https://lh3.googleusercontent.com/t55AtJJ9szplBUbEchUAE_tyZuYTeSenjd7iHfVPfwsvIX3lof2kcI9jzGcpZ1Prf3oFiYLdcVsO0aFNCo-j6sgYUY0x32IEngz9s8I=s250\" , \"representation\" : \"PREVIEW\" }, { \"@type\" : \"VIDEO\" , \"url\" : \"https://storage.opensea.io/files/cec338c0f5685f3037096b7bed283e15.wav\" , \"representation\" : \"ORIGINAL\" } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } ] } get Item by Id Returns Item by Id https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } get All Items Returns All Items https://api.rarible.org/v0.1/items/all Example request (staging) curl --request GET 'https://api.rarible.org/v0.1/items/all?blockchains=POLYGON&size=1' Example response (status 200) { \"total\" : 1 , \"continuation\" : \"POLYGON:1648131545251_0x4d544035500d7ac1b42329c70eb58e77f8249f0f:3874767738\" , \"items\" : [ { \"id\" : \"POLYGON:0x4d544035500d7ac1b42329c70eb58e77f8249f0f:3874767738\" , \"blockchain\" : \"POLYGON\" , \"collection\" : \"POLYGON:0x4d544035500d7ac1b42329c70eb58e77f8249f0f\" , \"contract\" : \"POLYGON:0x4d544035500d7ac1b42329c70eb58e77f8249f0f\" , \"tokenId\" : \"3874767738\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x517c295d34137a2f4b3026656c09dd62e668fc72\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-24T14:18:11Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:19:05.251Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"LOK Food 5M\" , \"description\" : \"League of Kingdoms Resource\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://lok-nft.leagueofkingdoms.com/resource/10101020.png\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/png\" , \"width\" : 200 , \"height\" : 200 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } ] } Orders \u00b6 get Order by Id Returns Order by Id https://api.rarible.org/v0.1/orders/{id} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x1641f3a030a1e810abe15c70320ab0e4cf1ee59c0baa3a77cf8b409aa0a0d320' Request parameters: id \u2014 order Id, has format ${blockchain}:${id} . For example, ETHEREUM:0x1641f3a030a1e810abe15c70320ab0e4cf1ee59c0baa3a77cf8b409aa0a0d320 Example response (status 200) { \"id\" : \"ETHEREUM:0x1641f3a030a1e810abe15c70320ab0e4cf1ee59c0baa3a77cf8b409aa0a0d320\" , \"fill\" : \"0\" , \"platform\" : \"OPEN_SEA\" , \"status\" : \"INACTIVE\" , \"startedAt\" : \"2022-03-24T14:27:33Z\" , \"endedAt\" : \"2022-09-20T14:29:08Z\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-24T14:29:15.790Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:29:15.790Z\" , \"makePrice\" : \"0.01\" , \"makePriceUsd\" : \"30.198384450784797\" , \"priceHistory\" : [ { \"date\" : \"2022-03-24T14:29:15.790Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.01\" } ], \"maker\" : \"ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155\" , \"contract\" : \"ETHEREUM:0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656\" , \"tokenId\" : \"103834860413964016633619762390589326621035685084276300587330678503415507582977\" }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.01\" }, \"salt\" : \"0xd49cbf21e348826dff4760cf9c22af9bd877809341ad0e5d0e899d60d8d59553\" , \"signature\" : \"0x45face93c43bdb3375e02b5140c4ec380a112b82c81fa78a5f6e7d15206d997629e5427476302f66cfae79488ca5591bc667de4c8847b56c81d90e2a76a9f8021c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_OPEN_SEA_V1\" , \"exchange\" : \"ETHEREUM:0xdd54d660178b28f6033a953b0e55073cfa7e3744\" , \"makerRelayerFee\" : \"1250\" , \"takerRelayerFee\" : \"0\" , \"makerProtocolFee\" : \"0\" , \"takerProtocolFee\" : \"0\" , \"feeRecipient\" : \"ETHEREUM:0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\" , \"feeMethod\" : \"SPLIT_FEE\" , \"side\" : \"SELL\" , \"saleKind\" : \"FIXED_PRICE\" , \"howToCall\" : \"DELEGATE_CALL\" , \"callData\" : \"0x96809f90000000000000000000000000e59072c5084ec2dc16e6bcdc3560802ffbafb5cb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088b48f654c30e99bc2e4a1559b4dcf1ad93fa656e59072c5084ec2dc16e6bcdc3560802ffbafb5cb00000000000a9e00000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000\" , \"replacementPattern\" : \"0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"staticTarget\" : \"ETHEREUM:0x0000000000000000000000000000000000000000\" , \"staticExtraData\" : \"0x\" , \"extra\" : \"0\" } } get Sell Orders by maker Returns Sell Orders by maker https://api.rarible.org/v0.1/orders/sell/byMaker Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/sell/byMaker?maker=ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb&size=1' Request parameters: maker \u2014 the maker of the order, has format ${blockchain}:${id} . For example, ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb Example response (status 200) { \"continuation\" : \"1648132919811_0xf8e3f895591ac3f6ff4a516ea17ac1c12b21c3d93acfa3e808e16f1467bb7c52\" , \"orders\" : [ { \"id\" : \"ETHEREUM:0xf8e3f895591ac3f6ff4a516ea17ac1c12b21c3d93acfa3e808e16f1467bb7c52\" , \"fill\" : \"0\" , \"platform\" : \"OPEN_SEA\" , \"status\" : \"INACTIVE\" , \"startedAt\" : \"2022-03-24T14:40:16Z\" , \"endedAt\" : \"2022-09-20T14:41:52Z\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-24T14:41:59.811Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:41:59.811Z\" , \"makePrice\" : \"0.01\" , \"makePriceUsd\" : \"30.198384450784797\" , \"priceHistory\" : [ { \"date\" : \"2022-03-24T14:41:59.811Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.01\" } ], \"maker\" : \"ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155\" , \"contract\" : \"ETHEREUM:0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656\" , \"tokenId\" : \"103834860413964016633619762390589326621035685084276300587330678545196949438465\" }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.01\" }, \"salt\" : \"0x0b06c99560930d99286981d16bdee68a8a10e872bc7718e662a144ab63eb854b\" , \"signature\" : \"0xee243d7bdb69518ea6c9c9cbfb4163e49111ec476b870f07c61c549b72927d332321ba1fceb1b2db7e26e4994a25fc18e0da2e729737deb8ae84f0c54c7f3d7c1c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_OPEN_SEA_V1\" , \"exchange\" : \"ETHEREUM:0xdd54d660178b28f6033a953b0e55073cfa7e3744\" , \"makerRelayerFee\" : \"1250\" , \"takerRelayerFee\" : \"0\" , \"makerProtocolFee\" : \"0\" , \"takerProtocolFee\" : \"0\" , \"feeRecipient\" : \"ETHEREUM:0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\" , \"feeMethod\" : \"SPLIT_FEE\" , \"side\" : \"SELL\" , \"saleKind\" : \"FIXED_PRICE\" , \"howToCall\" : \"DELEGATE_CALL\" , \"callData\" : \"0x96809f90000000000000000000000000e59072c5084ec2dc16e6bcdc3560802ffbafb5cb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088b48f654c30e99bc2e4a1559b4dcf1ad93fa656e59072c5084ec2dc16e6bcdc3560802ffbafb5cb00000000000ac400000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000\" , \"replacementPattern\" : \"0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"staticTarget\" : \"ETHEREUM:0x0000000000000000000000000000000000000000\" , \"staticExtraData\" : \"0x\" , \"extra\" : \"0\" } } ] } get All Orders Returns all Orders https://api.rarible.org/v0.1/orders/all Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/all?size=1' Example response (status 200) { \"continuation\" : \"ETHEREUM:1648132257821_0x487cf9fc8c7713dd634e2d0698fde08fba134ce81e515a9c7b75121096ced384\" , \"orders\" : [ { \"id\" : \"ETHEREUM:0x487cf9fc8c7713dd634e2d0698fde08fba134ce81e515a9c7b75121096ced384\" , \"fill\" : \"0\" , \"platform\" : \"RARIBLE\" , \"status\" : \"ACTIVE\" , \"makeStock\" : \"1\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-24T14:30:57.821Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:30:57.821Z\" , \"makePrice\" : \"0.01\" , \"makePriceUsd\" : \"30.198384450784797\" , \"priceHistory\" : [ { \"date\" : \"2022-03-24T14:30:57.821Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.01\" } ], \"maker\" : \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\" , \"make\" : { \"type\" : { \"@type\" : \"ERC721_Lazy\" , \"contract\" : \"ETHEREUM:0x6110ea0489c929b44152e99c133e17025a684223\" , \"tokenId\" : \"29022402683878927866272288177291204022157824894707812777715415655733163720747\" , \"uri\" : \"/ipfs/Qmb37SGcSV3ELHeZSzcZt5ymERUn9ug5vtqmPQfs7yFQUm\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\" , \"value\" : 1000 } ], \"signatures\" : [ \"0x60647533cdabee46b8e40b19cfcc588585d306ce061ddaf50e5dc8187ea6e0e955e91ef1d61a4cbf17dc81136bdadccf6052d54791fa3dbad65bd5925932e7191c\" ] }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.01\" }, \"salt\" : \"0x4605d2c0a64793ea84b6b58edf2326356d5562eeeb4e550f2b79bb965f984ac4\" , \"signature\" : \"0xd67ffbe94321dce166ff3028546914547a9f6d44ba434db20e0244f83626862e41606a1254f5c7565bce88ae78d7f5f0214553b6dd6d5cd4f9198302d5c1fa781c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"ETHEREUM:0x76c5855e93bd498b6331652854c4549d34bc3a30\" , \"value\" : 250 } ] } } ] } Collections \u00b6 get Collections by owner Returns Collections by owner https://api.rarible.org/v0.1/collections/byOwner Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/byOwner?owner=ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420' Request parameters: owner \u2014 address of the collection owner, has format ${blockchain}:${address} . For example, ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420 Example response (status 200) { \"total\" : 1 , \"collections\" : [ { \"id\" : \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"Test\" , \"symbol\" : \"TEST\" , \"owner\" : \"ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Untitled\" , \"content\" : [] } } ] } get Collection by Id Returns Collection by Id https://api.rarible.org/v0.1/collections/{collection} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7' Request parameters: collection \u2014 collection address, has format ${blockchain}:${address} . For example, POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7 Example response (status 200) { \"id\" : \"POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7\" , \"blockchain\" : \"POLYGON\" , \"type\" : \"ERC721\" , \"name\" : \"LUCA\" , \"symbol\" : \"InvoiceNFT\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Untitled\" , \"content\" : [] } } get All Collections Returns all Collections https://api.rarible.org/v0.1/collections/all Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/all?blockchains=ETHEREUM&size=1' Example response (status 200) { \"total\" : 1 , \"continuation\" : \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\" , \"collections\" : [ { \"id\" : \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"Test\" , \"symbol\" : \"TEST\" , \"owner\" : \"ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Untitled\" , \"content\" : [] } } ] } Ownerships \u00b6 get Ownerships by Item Returns Ownerships by Item https://api.rarible.org/v0.1/ownerships/byItem Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/ownerships/byItem?itemId=ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765' Request parameters: itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"total\" : 1 , \"ownerships\" : [ { \"id\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"blockchain\" : \"ETHEREUM\" , \"itemId\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765\" , \"contract\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"collection\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"tokenId\" : \"765\" , \"owner\" : \"ETHEREUM:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"value\" : \"1\" , \"createdAt\" : \"2022-03-24T16:20:05.015Z\" , \"creators\" : [], \"lazyValue\" : \"0\" , \"pending\" : [] } ] } get Ownerships by Id Returns Ownerships by Id https://api.rarible.org/v0.1/ownerships/{ownershipId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/ownerships/ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3' Request parameters: ownershipId \u2014 ownership Id in format ${blockchain}:${token}:${tokenId}:${owner} . For example, ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3 Example response (status 200) { \"id\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"blockchain\" : \"ETHEREUM\" , \"itemId\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765\" , \"contract\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"collection\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"tokenId\" : \"765\" , \"owner\" : \"ETHEREUM:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"value\" : \"1\" , \"createdAt\" : \"2022-03-24T16:20:05.015Z\" , \"creators\" : [], \"lazyValue\" : \"0\" , \"pending\" : [] } Activity \u00b6 We have several query parameters for paging and continuation in the Activity controller methods: size \u2014 the maximum number of results per page to return continuation \u2014 deprecated parameter cursor \u2014 combined continuation token from the previous response, type of page token. Can be used to get the next page of results in a subsequent list request. Has format ${BLOCKCHAIN}:${TS_MS}_{ENTITY_ID};... , where: BLOCKCHAIN \u2014 blockchain name: ETHEREUM , FLOW , TEZOS , POLYGON or SOLANA TS_MS \u2014 timestamp of the data in ms ENTITY_ID \u2014 entity identifier, different blockchains have different identifier formats For example: POLYGON:1649395092000_624fc5956f6dc654e6095b90 ; ETHEREUM:1649395762000_624fc83a63c052298d2e2b61 ; SOLANA:1649395777000_000126563148:EjGVpJkNpjCakf5WcN13b8rZzxvDAnjVm7mgLam812xm:000185:4fGmEP5Cm3MURsGJ8mx1uEC7c2sWsVrAGdjC2PfCbamj5ZKZwwCRYTUWyoY3Yzo3JYr5TGqJEUnmB6ejFPChTNKJ:000000:000001 ; TEZOS:1649260825000_BMQpZgFjvunjfqe7JPbRihLxrAv89vR9wtaHBpf8H6FULqXQM6o_243 ; FLOW:1649159220612_a4a4ad0e64aa0a3e6820f8a546d9355045eb1ca2f4818b85f5c0085f8cae04b9.64 If the blockchain is not specified in the cursor , then no entries have been found for it according to the sorting results. To get the next page of results, set cursor returned by a previous list request. But we recommend using the cursor in automated mode, because it is not designed to be built by hand. If you still want to use it manually, use the following example to get the correct data. getAllActivities example https://api-staging.rarible.org/v0.1/activities/all Specify the query parameters: blockchains , activity type , and size : curl --request GET 'https://api-staging.rarible.org/v0.1/activities/all?blockchains=ETHEREUM&type=MINT&size=3' Example response (status 200) { \"continuation\" : \"1649398291000_624fd21b63c052298d2e43f9\" , \"cursor\" : \"ETHEREUM:1649398291000_624fd21b63c052298d2e43f9\" , \"activities\" : [ { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd23963c052298d2e4407\" , \"date\" : \"2022-04-08T06:12:02Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x33b5606763150120076308076c91f01132a799da\" , \"contract\" : \"ETHEREUM:0x2703b3753930fe36b5af2b9b6cba1615fdf31310\" , \"tokenId\" : \"2\" , \"itemId\" : \"ETHEREUM:0x2703b3753930fe36b5af2b9b6cba1615fdf31310:2\" , \"value\" : \"1\" , \"transactionHash\" : \"0x74fd40687d29f2ac584c14b46ad871d82e0fbe3332a2679370b1117c4fac0e57\" , \"blockchainInfo\" : { \"transactionHash\" : \"0x74fd40687d29f2ac584c14b46ad871d82e0fbe3332a2679370b1117c4fac0e57\" , \"blockHash\" : \"0xbd49cf6e7aad7c7e693ea675048033bfdfdea9665374de27283ee045ba7c9b91\" , \"blockNumber\" : 10467061 , \"logIndex\" : 21 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd23963c052298d2e4406\" , \"date\" : \"2022-04-08T06:12:02Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0xd4f6cb0c1fe07407b7098ac7fe4265f3b2ae61f2\" , \"contract\" : \"ETHEREUM:0x1e1e3fed3e83dfe729a29ace3b588169a586fd18\" , \"tokenId\" : \"1\" , \"itemId\" : \"ETHEREUM:0x1e1e3fed3e83dfe729a29ace3b588169a586fd18:1\" , \"value\" : \"1\" , \"transactionHash\" : \"0xa47279f35076d084a5bfa5abd4de71a3226d5b5f7424ceaa52fa81d179a2b8d6\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xa47279f35076d084a5bfa5abd4de71a3226d5b5f7424ceaa52fa81d179a2b8d6\" , \"blockHash\" : \"0xbd49cf6e7aad7c7e693ea675048033bfdfdea9665374de27283ee045ba7c9b91\" , \"blockNumber\" : 10467061 , \"logIndex\" : 0 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd21b63c052298d2e43f9\" , \"date\" : \"2022-04-08T06:11:31Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x739cc4746e106d050f757bcece2aafc9f2eaaa28\" , \"contract\" : \"ETHEREUM:0x25b284f96106bb046b9bd99ab167f060bcf18982\" , \"tokenId\" : \"10\" , \"itemId\" : \"ETHEREUM:0x25b284f96106bb046b9bd99ab167f060bcf18982:10\" , \"value\" : \"1\" , \"transactionHash\" : \"0x990b3b2157dad093de018da254fc52adbd89737c72cbd1a443253897a74a4161\" , \"blockchainInfo\" : { \"transactionHash\" : \"0x990b3b2157dad093de018da254fc52adbd89737c72cbd1a443253897a74a4161\" , \"blockHash\" : \"0xe5b01f69dba978cb52907a6d12938550fcab5bac1572c9d7ca5c7fab30d32c84\" , \"blockNumber\" : 10467059 , \"logIndex\" : 6 } } ] } As we see, ENTITY_ID part in the cursor is the same as id of the last element in the response: { ... \"cursor\" : \"ETHEREUM:1649398291000_624fd21b63c052298d2e43f9\" , \"activities\" : [ { ... { ... \"id\" : \"ETHEREUM:624fd21b63c052298d2e43f9\" , ... } } ] } Take the resulting cursor and add it to the new query: curl --request GET 'https://api-staging.rarible.org/v0.1/activities/all?blockchains=ETHEREUM&type=MINT&cursor=ETHEREUM:1649398291000_624fd21b63c052298d2e43f9&size=3' Example response (status 200) { \"cursor\" : \"ETHEREUM:1649398276000_624fd20e63c052298d2e42f6\" , \"activities\" : [ { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd20f63c052298d2e43e3\" , \"date\" : \"2022-04-08T06:11:16Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x77054b00ddbbe9c597d93156b964fc115dbc1685\" , \"contract\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb\" , \"tokenId\" : \"1011\" , \"itemId\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb:1011\" , \"value\" : \"1\" , \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockHash\" : \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\" , \"blockNumber\" : 10467058 , \"logIndex\" : 508 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd20f63c052298d2e43e2\" , \"date\" : \"2022-04-08T06:11:16Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x77054b00ddbbe9c597d93156b964fc115dbc1685\" , \"contract\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb\" , \"tokenId\" : \"1012\" , \"itemId\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb:1012\" , \"value\" : \"1\" , \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockHash\" : \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\" , \"blockNumber\" : 10467058 , \"logIndex\" : 507 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd20e63c052298d2e42f6\" , \"date\" : \"2022-04-08T06:11:16Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x0ade6d84cb1b8fe9ab8c8145f53b202c426a34f3\" , \"contract\" : \"ETHEREUM:0x4fc8df260a04683421d3949baf182f9556f3a9f9\" , \"tokenId\" : \"2\" , \"itemId\" : \"ETHEREUM:0x4fc8df260a04683421d3949baf182f9556f3a9f9:2\" , \"value\" : \"1\" , \"transactionHash\" : \"0xbf231cf9a46ff83484eb39ac73c1d4a806e8376a19fc3c6549d7777c186cd2b3\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xbf231cf9a46ff83484eb39ac73c1d4a806e8376a19fc3c6549d7777c186cd2b3\" , \"blockHash\" : \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\" , \"blockNumber\" : 10467058 , \"logIndex\" : 17 } } ] } Repeat this step with the newly obtained cursor , if necessary. On the multichain.redoc.ly you can find more information about Protocol Multichain API.","title":"Search Capabilities"},{"location":"reference/search-capabilities/#search-capabilities","text":"On the multichain.redoc.ly you can find main information about Protocol API.","title":"Search Capabilities"},{"location":"reference/search-capabilities/#controllers","text":"Use the following controllers to search information about NFT with our multichain API: Signature controller \u2014 uses for validation of the order signature Currency controller \u2014 getting currency USD rate Item controller \u2014 getting information about NFT items Ownership controller \u2014 getting information about NFT items ownership Order controller \u2014 getting information about NFT orders Auction controller \u2014 getting information about NFT auctions Activity controller \u2014 getting information about activities with NFT Collection controller \u2014 getting information about NFT collections","title":"Controllers"},{"location":"reference/search-capabilities/#api-usage-examples","text":"","title":"API usage Examples"},{"location":"reference/search-capabilities/#items","text":"get Item by owner Returns Item by owner https://api.rarible.org/v0.1/items/byOwner Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/byOwner?owner=ETHEREUM:0x66606fe12f319a8f781a9af35c3d061617ea642a&size=1' Request parameters: owner \u2014 address of the item owner, has format ${blockchain}:${address} . For example, ETHEREUM:0x66606fe12f319a8f781a9af35c3d061617ea642a Example response (status 200) { \"total\" : 1 , \"continuation\" : \"1648125753039_0x08295565739cf720f2a61e5237815eacfad98c6a:2102\" , \"items\" : [ { \"id\" : \"ETHEREUM:0x08295565739cf720f2a61e5237815eacfad98c6a:2102\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x08295565739cf720f2a61e5237815eacfad98c6a\" , \"contract\" : \"ETHEREUM:0x08295565739cf720f2a61e5237815eacfad98c6a\" , \"tokenId\" : \"2102\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x66606fe12f319a8f781a9af35c3d061617ea642a\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-24T12:42:33Z\" , \"lastUpdatedAt\" : \"2022-03-24T12:42:33.039Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"\u634c\uff1a\u4eba\u6d77\u832b\u832b #\\n2102\" , \"description\" : \"\u4eba\u6d77\u554a\u832b\u832b\u554a-\u300a\u6d77\u8349\u821e\u300bNFT \\n\\n\u4eba\u6d77\u554a \u832b\u832b\u554a \u968f\u6ce2\u9010\u6d41 \u6d6e\u6d6e\u6c89\u6c89\" , \"attributes\" : [ { \"key\" : \"\u6f14\u5531\" , \"value\" : \"\u8427\u5168\" }, { \"key\" : \"\u4f5c\u8bcd\" , \"value\" : \"\u8427\u5168\" }, { \"key\" : \"\u4f5c\u66f2\" , \"value\" : \"\u8427\u5168\" }, { \"key\" : \"\u7a00\u6709\u5ea6\" , \"value\" : \"\u7f55\u89c1\" } ], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmbyFuDKZc9UkxMNJ7t25cZk7mm8u77c3FENFsatxN4VNk/8.png\" , \"representation\" : \"ORIGINAL\" }, { \"@type\" : \"IMAGE\" , \"url\" : \"https://lh3.googleusercontent.com/t55AtJJ9szplBUbEchUAE_tyZuYTeSenjd7iHfVPfwsvIX3lof2kcI9jzGcpZ1Prf3oFiYLdcVsO0aFNCo-j6sgYUY0x32IEngz9s8I\" , \"representation\" : \"BIG\" }, { \"@type\" : \"IMAGE\" , \"url\" : \"https://lh3.googleusercontent.com/t55AtJJ9szplBUbEchUAE_tyZuYTeSenjd7iHfVPfwsvIX3lof2kcI9jzGcpZ1Prf3oFiYLdcVsO0aFNCo-j6sgYUY0x32IEngz9s8I=s250\" , \"representation\" : \"PREVIEW\" }, { \"@type\" : \"VIDEO\" , \"url\" : \"https://storage.opensea.io/files/cec338c0f5685f3037096b7bed283e15.wav\" , \"representation\" : \"ORIGINAL\" } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } ] } get Item by Id Returns Item by Id https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } get All Items Returns All Items https://api.rarible.org/v0.1/items/all Example request (staging) curl --request GET 'https://api.rarible.org/v0.1/items/all?blockchains=POLYGON&size=1' Example response (status 200) { \"total\" : 1 , \"continuation\" : \"POLYGON:1648131545251_0x4d544035500d7ac1b42329c70eb58e77f8249f0f:3874767738\" , \"items\" : [ { \"id\" : \"POLYGON:0x4d544035500d7ac1b42329c70eb58e77f8249f0f:3874767738\" , \"blockchain\" : \"POLYGON\" , \"collection\" : \"POLYGON:0x4d544035500d7ac1b42329c70eb58e77f8249f0f\" , \"contract\" : \"POLYGON:0x4d544035500d7ac1b42329c70eb58e77f8249f0f\" , \"tokenId\" : \"3874767738\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x517c295d34137a2f4b3026656c09dd62e668fc72\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-24T14:18:11Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:19:05.251Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"LOK Food 5M\" , \"description\" : \"League of Kingdoms Resource\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://lok-nft.leagueofkingdoms.com/resource/10101020.png\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/png\" , \"width\" : 200 , \"height\" : 200 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } ] }","title":"Items"},{"location":"reference/search-capabilities/#orders","text":"get Order by Id Returns Order by Id https://api.rarible.org/v0.1/orders/{id} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/ETHEREUM:0x1641f3a030a1e810abe15c70320ab0e4cf1ee59c0baa3a77cf8b409aa0a0d320' Request parameters: id \u2014 order Id, has format ${blockchain}:${id} . For example, ETHEREUM:0x1641f3a030a1e810abe15c70320ab0e4cf1ee59c0baa3a77cf8b409aa0a0d320 Example response (status 200) { \"id\" : \"ETHEREUM:0x1641f3a030a1e810abe15c70320ab0e4cf1ee59c0baa3a77cf8b409aa0a0d320\" , \"fill\" : \"0\" , \"platform\" : \"OPEN_SEA\" , \"status\" : \"INACTIVE\" , \"startedAt\" : \"2022-03-24T14:27:33Z\" , \"endedAt\" : \"2022-09-20T14:29:08Z\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-24T14:29:15.790Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:29:15.790Z\" , \"makePrice\" : \"0.01\" , \"makePriceUsd\" : \"30.198384450784797\" , \"priceHistory\" : [ { \"date\" : \"2022-03-24T14:29:15.790Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.01\" } ], \"maker\" : \"ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155\" , \"contract\" : \"ETHEREUM:0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656\" , \"tokenId\" : \"103834860413964016633619762390589326621035685084276300587330678503415507582977\" }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.01\" }, \"salt\" : \"0xd49cbf21e348826dff4760cf9c22af9bd877809341ad0e5d0e899d60d8d59553\" , \"signature\" : \"0x45face93c43bdb3375e02b5140c4ec380a112b82c81fa78a5f6e7d15206d997629e5427476302f66cfae79488ca5591bc667de4c8847b56c81d90e2a76a9f8021c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_OPEN_SEA_V1\" , \"exchange\" : \"ETHEREUM:0xdd54d660178b28f6033a953b0e55073cfa7e3744\" , \"makerRelayerFee\" : \"1250\" , \"takerRelayerFee\" : \"0\" , \"makerProtocolFee\" : \"0\" , \"takerProtocolFee\" : \"0\" , \"feeRecipient\" : \"ETHEREUM:0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\" , \"feeMethod\" : \"SPLIT_FEE\" , \"side\" : \"SELL\" , \"saleKind\" : \"FIXED_PRICE\" , \"howToCall\" : \"DELEGATE_CALL\" , \"callData\" : \"0x96809f90000000000000000000000000e59072c5084ec2dc16e6bcdc3560802ffbafb5cb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088b48f654c30e99bc2e4a1559b4dcf1ad93fa656e59072c5084ec2dc16e6bcdc3560802ffbafb5cb00000000000a9e00000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000\" , \"replacementPattern\" : \"0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"staticTarget\" : \"ETHEREUM:0x0000000000000000000000000000000000000000\" , \"staticExtraData\" : \"0x\" , \"extra\" : \"0\" } } get Sell Orders by maker Returns Sell Orders by maker https://api.rarible.org/v0.1/orders/sell/byMaker Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/sell/byMaker?maker=ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb&size=1' Request parameters: maker \u2014 the maker of the order, has format ${blockchain}:${id} . For example, ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb Example response (status 200) { \"continuation\" : \"1648132919811_0xf8e3f895591ac3f6ff4a516ea17ac1c12b21c3d93acfa3e808e16f1467bb7c52\" , \"orders\" : [ { \"id\" : \"ETHEREUM:0xf8e3f895591ac3f6ff4a516ea17ac1c12b21c3d93acfa3e808e16f1467bb7c52\" , \"fill\" : \"0\" , \"platform\" : \"OPEN_SEA\" , \"status\" : \"INACTIVE\" , \"startedAt\" : \"2022-03-24T14:40:16Z\" , \"endedAt\" : \"2022-09-20T14:41:52Z\" , \"makeStock\" : \"0\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-24T14:41:59.811Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:41:59.811Z\" , \"makePrice\" : \"0.01\" , \"makePriceUsd\" : \"30.198384450784797\" , \"priceHistory\" : [ { \"date\" : \"2022-03-24T14:41:59.811Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.01\" } ], \"maker\" : \"ETHEREUM:0xe59072c5084ec2dc16e6bcdc3560802ffbafb5cb\" , \"make\" : { \"type\" : { \"@type\" : \"ERC1155\" , \"contract\" : \"ETHEREUM:0x88b48f654c30e99bc2e4a1559b4dcf1ad93fa656\" , \"tokenId\" : \"103834860413964016633619762390589326621035685084276300587330678545196949438465\" }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.01\" }, \"salt\" : \"0x0b06c99560930d99286981d16bdee68a8a10e872bc7718e662a144ab63eb854b\" , \"signature\" : \"0xee243d7bdb69518ea6c9c9cbfb4163e49111ec476b870f07c61c549b72927d332321ba1fceb1b2db7e26e4994a25fc18e0da2e729737deb8ae84f0c54c7f3d7c1c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_OPEN_SEA_V1\" , \"exchange\" : \"ETHEREUM:0xdd54d660178b28f6033a953b0e55073cfa7e3744\" , \"makerRelayerFee\" : \"1250\" , \"takerRelayerFee\" : \"0\" , \"makerProtocolFee\" : \"0\" , \"takerProtocolFee\" : \"0\" , \"feeRecipient\" : \"ETHEREUM:0x5b3256965e7c3cf26e11fcaf296dfc8807c01073\" , \"feeMethod\" : \"SPLIT_FEE\" , \"side\" : \"SELL\" , \"saleKind\" : \"FIXED_PRICE\" , \"howToCall\" : \"DELEGATE_CALL\" , \"callData\" : \"0x96809f90000000000000000000000000e59072c5084ec2dc16e6bcdc3560802ffbafb5cb000000000000000000000000000000000000000000000000000000000000000000000000000000000000000088b48f654c30e99bc2e4a1559b4dcf1ad93fa656e59072c5084ec2dc16e6bcdc3560802ffbafb5cb00000000000ac400000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000e00000000000000000000000000000000000000000000000000000000000000000\" , \"replacementPattern\" : \"0x000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\" , \"staticTarget\" : \"ETHEREUM:0x0000000000000000000000000000000000000000\" , \"staticExtraData\" : \"0x\" , \"extra\" : \"0\" } } ] } get All Orders Returns all Orders https://api.rarible.org/v0.1/orders/all Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/orders/all?size=1' Example response (status 200) { \"continuation\" : \"ETHEREUM:1648132257821_0x487cf9fc8c7713dd634e2d0698fde08fba134ce81e515a9c7b75121096ced384\" , \"orders\" : [ { \"id\" : \"ETHEREUM:0x487cf9fc8c7713dd634e2d0698fde08fba134ce81e515a9c7b75121096ced384\" , \"fill\" : \"0\" , \"platform\" : \"RARIBLE\" , \"status\" : \"ACTIVE\" , \"makeStock\" : \"1\" , \"cancelled\" : false , \"createdAt\" : \"2022-03-24T14:30:57.821Z\" , \"lastUpdatedAt\" : \"2022-03-24T14:30:57.821Z\" , \"makePrice\" : \"0.01\" , \"makePriceUsd\" : \"30.198384450784797\" , \"priceHistory\" : [ { \"date\" : \"2022-03-24T14:30:57.821Z\" , \"makeValue\" : \"1\" , \"takeValue\" : \"0.01\" } ], \"maker\" : \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\" , \"make\" : { \"type\" : { \"@type\" : \"ERC721_Lazy\" , \"contract\" : \"ETHEREUM:0x6110ea0489c929b44152e99c133e17025a684223\" , \"tokenId\" : \"29022402683878927866272288177291204022157824894707812777715415655733163720747\" , \"uri\" : \"/ipfs/Qmb37SGcSV3ELHeZSzcZt5ymERUn9ug5vtqmPQfs7yFQUm\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\" , \"value\" : 10000 } ], \"royalties\" : [ { \"account\" : \"ETHEREUM:0x402a19096d7e4d1cbe74fc92b4e21bf33614e1a5\" , \"value\" : 1000 } ], \"signatures\" : [ \"0x60647533cdabee46b8e40b19cfcc588585d306ce061ddaf50e5dc8187ea6e0e955e91ef1d61a4cbf17dc81136bdadccf6052d54791fa3dbad65bd5925932e7191c\" ] }, \"value\" : \"1\" }, \"take\" : { \"type\" : { \"@type\" : \"ETH\" , \"blockchain\" : \"ETHEREUM\" }, \"value\" : \"0.01\" }, \"salt\" : \"0x4605d2c0a64793ea84b6b58edf2326356d5562eeeb4e550f2b79bb965f984ac4\" , \"signature\" : \"0xd67ffbe94321dce166ff3028546914547a9f6d44ba434db20e0244f83626862e41606a1254f5c7565bce88ae78d7f5f0214553b6dd6d5cd4f9198302d5c1fa781c\" , \"pending\" : [], \"data\" : { \"@type\" : \"ETH_RARIBLE_V2\" , \"payouts\" : [], \"originFees\" : [ { \"account\" : \"ETHEREUM:0x76c5855e93bd498b6331652854c4549d34bc3a30\" , \"value\" : 250 } ] } } ] }","title":"Orders"},{"location":"reference/search-capabilities/#collections","text":"get Collections by owner Returns Collections by owner https://api.rarible.org/v0.1/collections/byOwner Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/byOwner?owner=ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420' Request parameters: owner \u2014 address of the collection owner, has format ${blockchain}:${address} . For example, ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420 Example response (status 200) { \"total\" : 1 , \"collections\" : [ { \"id\" : \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"Test\" , \"symbol\" : \"TEST\" , \"owner\" : \"ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Untitled\" , \"content\" : [] } } ] } get Collection by Id Returns Collection by Id https://api.rarible.org/v0.1/collections/{collection} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7' Request parameters: collection \u2014 collection address, has format ${blockchain}:${address} . For example, POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7 Example response (status 200) { \"id\" : \"POLYGON:0x00000000004ba8d1691a4c215fd2bd99771dccc7\" , \"blockchain\" : \"POLYGON\" , \"type\" : \"ERC721\" , \"name\" : \"LUCA\" , \"symbol\" : \"InvoiceNFT\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Untitled\" , \"content\" : [] } } get All Collections Returns all Collections https://api.rarible.org/v0.1/collections/all Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/collections/all?blockchains=ETHEREUM&size=1' Example response (status 200) { \"total\" : 1 , \"continuation\" : \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\" , \"collections\" : [ { \"id\" : \"ETHEREUM:0x0000000007dbc95a44e65b0439427de8236c53d3\" , \"blockchain\" : \"ETHEREUM\" , \"type\" : \"ERC721\" , \"name\" : \"Test\" , \"symbol\" : \"TEST\" , \"owner\" : \"ETHEREUM:0x8b3e026252ab4299d69779b4f533913e76a40420\" , \"features\" : [ \"APPROVE_FOR_ALL\" ], \"minters\" : [], \"meta\" : { \"name\" : \"Untitled\" , \"content\" : [] } } ] }","title":"Collections"},{"location":"reference/search-capabilities/#ownerships","text":"get Ownerships by Item Returns Ownerships by Item https://api.rarible.org/v0.1/ownerships/byItem Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/ownerships/byItem?itemId=ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765' Request parameters: itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"total\" : 1 , \"ownerships\" : [ { \"id\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"blockchain\" : \"ETHEREUM\" , \"itemId\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765\" , \"contract\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"collection\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"tokenId\" : \"765\" , \"owner\" : \"ETHEREUM:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"value\" : \"1\" , \"createdAt\" : \"2022-03-24T16:20:05.015Z\" , \"creators\" : [], \"lazyValue\" : \"0\" , \"pending\" : [] } ] } get Ownerships by Id Returns Ownerships by Id https://api.rarible.org/v0.1/ownerships/{ownershipId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/ownerships/ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3' Request parameters: ownershipId \u2014 ownership Id in format ${blockchain}:${token}:${tokenId}:${owner} . For example, ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3 Example response (status 200) { \"id\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"blockchain\" : \"ETHEREUM\" , \"itemId\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33:765\" , \"contract\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"collection\" : \"ETHEREUM:0x63ad270fc18f6f9435c3e205f06e003d3b861d33\" , \"tokenId\" : \"765\" , \"owner\" : \"ETHEREUM:0xe64ebc77ef72df8a7689d8928bc004b9e7ff43b3\" , \"value\" : \"1\" , \"createdAt\" : \"2022-03-24T16:20:05.015Z\" , \"creators\" : [], \"lazyValue\" : \"0\" , \"pending\" : [] }","title":"Ownerships"},{"location":"reference/search-capabilities/#activity","text":"We have several query parameters for paging and continuation in the Activity controller methods: size \u2014 the maximum number of results per page to return continuation \u2014 deprecated parameter cursor \u2014 combined continuation token from the previous response, type of page token. Can be used to get the next page of results in a subsequent list request. Has format ${BLOCKCHAIN}:${TS_MS}_{ENTITY_ID};... , where: BLOCKCHAIN \u2014 blockchain name: ETHEREUM , FLOW , TEZOS , POLYGON or SOLANA TS_MS \u2014 timestamp of the data in ms ENTITY_ID \u2014 entity identifier, different blockchains have different identifier formats For example: POLYGON:1649395092000_624fc5956f6dc654e6095b90 ; ETHEREUM:1649395762000_624fc83a63c052298d2e2b61 ; SOLANA:1649395777000_000126563148:EjGVpJkNpjCakf5WcN13b8rZzxvDAnjVm7mgLam812xm:000185:4fGmEP5Cm3MURsGJ8mx1uEC7c2sWsVrAGdjC2PfCbamj5ZKZwwCRYTUWyoY3Yzo3JYr5TGqJEUnmB6ejFPChTNKJ:000000:000001 ; TEZOS:1649260825000_BMQpZgFjvunjfqe7JPbRihLxrAv89vR9wtaHBpf8H6FULqXQM6o_243 ; FLOW:1649159220612_a4a4ad0e64aa0a3e6820f8a546d9355045eb1ca2f4818b85f5c0085f8cae04b9.64 If the blockchain is not specified in the cursor , then no entries have been found for it according to the sorting results. To get the next page of results, set cursor returned by a previous list request. But we recommend using the cursor in automated mode, because it is not designed to be built by hand. If you still want to use it manually, use the following example to get the correct data. getAllActivities example https://api-staging.rarible.org/v0.1/activities/all Specify the query parameters: blockchains , activity type , and size : curl --request GET 'https://api-staging.rarible.org/v0.1/activities/all?blockchains=ETHEREUM&type=MINT&size=3' Example response (status 200) { \"continuation\" : \"1649398291000_624fd21b63c052298d2e43f9\" , \"cursor\" : \"ETHEREUM:1649398291000_624fd21b63c052298d2e43f9\" , \"activities\" : [ { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd23963c052298d2e4407\" , \"date\" : \"2022-04-08T06:12:02Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x33b5606763150120076308076c91f01132a799da\" , \"contract\" : \"ETHEREUM:0x2703b3753930fe36b5af2b9b6cba1615fdf31310\" , \"tokenId\" : \"2\" , \"itemId\" : \"ETHEREUM:0x2703b3753930fe36b5af2b9b6cba1615fdf31310:2\" , \"value\" : \"1\" , \"transactionHash\" : \"0x74fd40687d29f2ac584c14b46ad871d82e0fbe3332a2679370b1117c4fac0e57\" , \"blockchainInfo\" : { \"transactionHash\" : \"0x74fd40687d29f2ac584c14b46ad871d82e0fbe3332a2679370b1117c4fac0e57\" , \"blockHash\" : \"0xbd49cf6e7aad7c7e693ea675048033bfdfdea9665374de27283ee045ba7c9b91\" , \"blockNumber\" : 10467061 , \"logIndex\" : 21 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd23963c052298d2e4406\" , \"date\" : \"2022-04-08T06:12:02Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0xd4f6cb0c1fe07407b7098ac7fe4265f3b2ae61f2\" , \"contract\" : \"ETHEREUM:0x1e1e3fed3e83dfe729a29ace3b588169a586fd18\" , \"tokenId\" : \"1\" , \"itemId\" : \"ETHEREUM:0x1e1e3fed3e83dfe729a29ace3b588169a586fd18:1\" , \"value\" : \"1\" , \"transactionHash\" : \"0xa47279f35076d084a5bfa5abd4de71a3226d5b5f7424ceaa52fa81d179a2b8d6\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xa47279f35076d084a5bfa5abd4de71a3226d5b5f7424ceaa52fa81d179a2b8d6\" , \"blockHash\" : \"0xbd49cf6e7aad7c7e693ea675048033bfdfdea9665374de27283ee045ba7c9b91\" , \"blockNumber\" : 10467061 , \"logIndex\" : 0 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd21b63c052298d2e43f9\" , \"date\" : \"2022-04-08T06:11:31Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x739cc4746e106d050f757bcece2aafc9f2eaaa28\" , \"contract\" : \"ETHEREUM:0x25b284f96106bb046b9bd99ab167f060bcf18982\" , \"tokenId\" : \"10\" , \"itemId\" : \"ETHEREUM:0x25b284f96106bb046b9bd99ab167f060bcf18982:10\" , \"value\" : \"1\" , \"transactionHash\" : \"0x990b3b2157dad093de018da254fc52adbd89737c72cbd1a443253897a74a4161\" , \"blockchainInfo\" : { \"transactionHash\" : \"0x990b3b2157dad093de018da254fc52adbd89737c72cbd1a443253897a74a4161\" , \"blockHash\" : \"0xe5b01f69dba978cb52907a6d12938550fcab5bac1572c9d7ca5c7fab30d32c84\" , \"blockNumber\" : 10467059 , \"logIndex\" : 6 } } ] } As we see, ENTITY_ID part in the cursor is the same as id of the last element in the response: { ... \"cursor\" : \"ETHEREUM:1649398291000_624fd21b63c052298d2e43f9\" , \"activities\" : [ { ... { ... \"id\" : \"ETHEREUM:624fd21b63c052298d2e43f9\" , ... } } ] } Take the resulting cursor and add it to the new query: curl --request GET 'https://api-staging.rarible.org/v0.1/activities/all?blockchains=ETHEREUM&type=MINT&cursor=ETHEREUM:1649398291000_624fd21b63c052298d2e43f9&size=3' Example response (status 200) { \"cursor\" : \"ETHEREUM:1649398276000_624fd20e63c052298d2e42f6\" , \"activities\" : [ { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd20f63c052298d2e43e3\" , \"date\" : \"2022-04-08T06:11:16Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x77054b00ddbbe9c597d93156b964fc115dbc1685\" , \"contract\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb\" , \"tokenId\" : \"1011\" , \"itemId\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb:1011\" , \"value\" : \"1\" , \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockHash\" : \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\" , \"blockNumber\" : 10467058 , \"logIndex\" : 508 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd20f63c052298d2e43e2\" , \"date\" : \"2022-04-08T06:11:16Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x77054b00ddbbe9c597d93156b964fc115dbc1685\" , \"contract\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb\" , \"tokenId\" : \"1012\" , \"itemId\" : \"ETHEREUM:0xce92876be6f0e6c795d55aca4eec1986c6db35eb:1012\" , \"value\" : \"1\" , \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xf6cd37b1ce91f16b0f4a1dce86e78d59b4cba6ad7352eaa15cb6fc32c853362a\" , \"blockHash\" : \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\" , \"blockNumber\" : 10467058 , \"logIndex\" : 507 } }, { \"@type\" : \"MINT\" , \"id\" : \"ETHEREUM:624fd20e63c052298d2e42f6\" , \"date\" : \"2022-04-08T06:11:16Z\" , \"reverted\" : false , \"owner\" : \"ETHEREUM:0x0ade6d84cb1b8fe9ab8c8145f53b202c426a34f3\" , \"contract\" : \"ETHEREUM:0x4fc8df260a04683421d3949baf182f9556f3a9f9\" , \"tokenId\" : \"2\" , \"itemId\" : \"ETHEREUM:0x4fc8df260a04683421d3949baf182f9556f3a9f9:2\" , \"value\" : \"1\" , \"transactionHash\" : \"0xbf231cf9a46ff83484eb39ac73c1d4a806e8376a19fc3c6549d7777c186cd2b3\" , \"blockchainInfo\" : { \"transactionHash\" : \"0xbf231cf9a46ff83484eb39ac73c1d4a806e8376a19fc3c6549d7777c186cd2b3\" , \"blockHash\" : \"0xc5a24c1dc49b5551b06f805edb4dd782cd46b3f21de71d3b250de6d767a625d9\" , \"blockNumber\" : 10467058 , \"logIndex\" : 17 } } ] } Repeat this step with the newly obtained cursor , if necessary. On the multichain.redoc.ly you can find more information about Protocol Multichain API.","title":"Activity"},{"location":"reference/transfer/","text":"Transfer \u00b6 You can transfer NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets . Transfer NFTs \u00b6 Use transferItem function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function transferItem ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const transferAction = await sdk . nft . transfer ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const tx = await transferAction . submit ({ to : toUnionAddress ( \"<ITEM_RECIPIENT>\" ), amount : 1 , }) await tx . wait () } itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 to \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh amount \u2014 amount of NFT tokens Checking transferred NFT \u00b6 To check the transferred item: Use the getItemById API method getItemById Returns Item by ID. https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Transfer"},{"location":"reference/transfer/#transfer","text":"You can transfer NFTs with Rarible Multichain Protocol in different blockchains. Before start, install and configure Rarible SDK and required wallets .","title":"Transfer"},{"location":"reference/transfer/#transfer-nfts","text":"Use transferItem function: import { createRaribleSdk } from \"@rarible/sdk\" import { toItemId , toUnionAddress } from \"@rarible/types\" import type { BlockchainWallet } from \"@rarible/sdk-wallet/src\" async function transferItem ( wallet : BlockchainWallet ) { const sdk = createRaribleSdk ( wallet , \"dev\" ) const transferAction = await sdk . nft . transfer ({ itemId : toItemId ( \"<YOUR_ITEM_ID>\" ), }) const tx = await transferAction . submit ({ to : toUnionAddress ( \"<ITEM_RECIPIENT>\" ), amount : 1 , }) await tx . wait () } itemId \u2014 Id of your NFT, has format ${blockchain}:${token}:${tokenId} . For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 to \u2014 address in Union format ${blockchainGroup}:${token} . For example, TEZOS:tz1dKxdpV1hgErMTTKBorb8R5tSz8hFzPhKh amount \u2014 amount of NFT tokens","title":"Transfer NFTs"},{"location":"reference/transfer/#checking-transferred-nft","text":"To check the transferred item: Use the getItemById API method getItemById Returns Item by ID. https://api.rarible.org/v0.1/items/{itemId} Example request (staging) curl --request GET 'https://api-staging.rarible.org/v0.1/items/ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243' Request parameters: itemId \u2014 ItemID of your NFT, has format ${blockchain}:${token}:${tokenId} For example, ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:12345 Example response (status 200) { \"id\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82:19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"blockchain\" : \"ETHEREUM\" , \"collection\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"contract\" : \"ETHEREUM:0x6ede7f3c26975aad32a475e1021d8f6f39c89d82\" , \"tokenId\" : \"19661880631107248865491477079747186145992059189823053172927066273904580362243\" , \"creators\" : [ { \"account\" : \"ETHEREUM:0x2b783ae5b5b8a7a822449c7d8b6f35f9abc827f5\" , \"value\" : 10000 } ], \"owners\" : [], \"royalties\" : [], \"lazySupply\" : \"0\" , \"pending\" : [], \"mintedAt\" : \"2022-03-09T22:48:33Z\" , \"lastUpdatedAt\" : \"2022-03-09T22:50:03.530Z\" , \"supply\" : \"1\" , \"meta\" : { \"name\" : \"gbgbgbgbgbgb\" , \"description\" : \"\" , \"attributes\" : [], \"content\" : [ { \"@type\" : \"IMAGE\" , \"url\" : \"https://rarible.mypinata.cloud/ipfs/QmQCp8bhbaPwGEuHeeR8pme2q3zuSjam2JEuFgAvp4DZsU/image.jpeg\" , \"representation\" : \"ORIGINAL\" , \"mimeType\" : \"image/jpeg\" , \"size\" : 13311 , \"width\" : 640 , \"height\" : 640 } ], \"restrictions\" : [] }, \"deleted\" : false , \"auctions\" : [], \"totalStock\" : \"0\" , \"sellers\" : 0 } Or check Etherscan for Ethereum and Polygon, Flowscan for Flow, or tezblock for Tezos. See more information about usage Protocol SDK on https://github.com/rarible/sdk","title":"Checking transferred NFT"},{"location":"reference/wallets/","text":"Wallets initialization \u00b6 To use SDK, you have to create a Wallet \u2014 abstraction to communicate with real blockchain wallets. Initialize wallets for used blockchains or use Rarible Wallet Connector (in general for frontend) It is possible to use SDK without wallet (for ex. sdk.balances.getBalance ), but in that case you can't send transactions and sign messages: const raribleSdk = createRaribleSdk ( undefined , \"prod\" ) Initialize simple wallets \u00b6 Ethereum / Polygon You can create EthereumWallet with one of the following providers: Web3 instance. For example, Metamask ( window.ethereum ) or HDWalletProvider ethers.providers.Web3Provider ethers.Wallet import Web3 from \"web3\" import * as HDWalletProvider from \"@truffle/hdwallet-provider\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { ethers } from \"ethers\" import { EthersEthereum , EthersWeb3ProviderEthereum } from \"@rarible/ethers-ethereum\" import { EthereumWallet } from \"@rarible/sdk-wallet\" //Creating EthereumWallet with Web3 const web3 = new Web3 ( provider ) const web3Ethereum = new Web3Ethereum ({ web3 }) const ethWallet = new EthereumWallet ( web3Ethereum ) //or with HDWalletProvider const provider = new HDWalletProvider ({ url : \"<NODE_URL>\" , privateKeys : [ \"0x0...\" ], chainId : 1 , }) const web3 = new Web3 ( provider ) const web3Ethereum = new Web3Ethereum ({ web3 }) const ethWallet = new EthereumWallet ( web3Ethereum ) //Creating EthereumWallet with ethers.providers.Web3Provider const ethersWeb3Provider = new ethers . providers . Web3Provider ( provider ) const ethersProvider = new EthersWeb3ProviderEthereum ( ethersWeb3Provider ) const ethWallet = new EthereumWallet ( ethersProvider ) //Creating EthereumWallet with ethers.Wallet const ethersWeb3Provider = new ethers . providers . Web3Provider ( provider ) const ethersProvider = new EthersEthereum ( new ethers . Wallet ( wallet . getPrivateKeyString (), ethersWeb3Provider )) const ethWallet = new EthereumWallet ( ethersProvider ) // Second parameter \u2014 is environment: \"prod\" | \"staging\" | \"e2e\" | \"dev\" const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ) Flow import * as fcl from \"@onflow/fcl\" import { FlowWallet } from \"@rarible/sdk-wallet\" const wallet = new FlowWallet ( fcl ) You also need to configure Flow Client Library (FCL), because Flow-sdk use @onflow/fcl-js : //example config for testnet import { config } from \"@onflow/fcl\" ; config ({ \"accessNode.api\" : \"https://access-testnet.onflow.org\" , // Mainnet: \"https://access-mainnet-beta.onflow.org\" \"discovery.wallet\" : \"https://fcl-discovery.onflow.org/testnet/authn\" // Mainnet: \"https://fcl-discovery.onflow.org/authn\" }) See more configuration details on Flow documentation . Tezos To initialize wallets, you can use: in_memory_provider (also for backend) beacon_provider (@rarible/tezos-sdk/dist/providers/beacon/beacon_provider) //in_memory_provider usage example import { in_memory_provider } from \"@rarible/tezos-sdk/dist/providers/in_memory/in_memory_provider\" import { TezosWallet } from \"@rarible/sdk-wallet\" const provider = in_memory_provider ( \"edsk...\" , nodeUrl ) const wallet = new TezosWallet ( provider ) Use Rarible SDK Wallet Connector \u00b6 Wallet Connector make possible to connect the following providers: InjectedWeb3ConnectionProvider \u2014 Metamask, Coinbase, etc FortmaticConnectionProvider PortisConnectionProvider TorusConnectionProvider WalletLinkConnectionProvider MEWConnectionProvider IframeConnectionProvider WalletConnectConnectionProvider BeaconConnectionProvider FclConnectionProvider Read more about installation and using examples of Rarible SDK Wallet Connector.","title":"Wallets"},{"location":"reference/wallets/#wallets-initialization","text":"To use SDK, you have to create a Wallet \u2014 abstraction to communicate with real blockchain wallets. Initialize wallets for used blockchains or use Rarible Wallet Connector (in general for frontend) It is possible to use SDK without wallet (for ex. sdk.balances.getBalance ), but in that case you can't send transactions and sign messages: const raribleSdk = createRaribleSdk ( undefined , \"prod\" )","title":"Wallets initialization"},{"location":"reference/wallets/#initialize-simple-wallets","text":"Ethereum / Polygon You can create EthereumWallet with one of the following providers: Web3 instance. For example, Metamask ( window.ethereum ) or HDWalletProvider ethers.providers.Web3Provider ethers.Wallet import Web3 from \"web3\" import * as HDWalletProvider from \"@truffle/hdwallet-provider\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { ethers } from \"ethers\" import { EthersEthereum , EthersWeb3ProviderEthereum } from \"@rarible/ethers-ethereum\" import { EthereumWallet } from \"@rarible/sdk-wallet\" //Creating EthereumWallet with Web3 const web3 = new Web3 ( provider ) const web3Ethereum = new Web3Ethereum ({ web3 }) const ethWallet = new EthereumWallet ( web3Ethereum ) //or with HDWalletProvider const provider = new HDWalletProvider ({ url : \"<NODE_URL>\" , privateKeys : [ \"0x0...\" ], chainId : 1 , }) const web3 = new Web3 ( provider ) const web3Ethereum = new Web3Ethereum ({ web3 }) const ethWallet = new EthereumWallet ( web3Ethereum ) //Creating EthereumWallet with ethers.providers.Web3Provider const ethersWeb3Provider = new ethers . providers . Web3Provider ( provider ) const ethersProvider = new EthersWeb3ProviderEthereum ( ethersWeb3Provider ) const ethWallet = new EthereumWallet ( ethersProvider ) //Creating EthereumWallet with ethers.Wallet const ethersWeb3Provider = new ethers . providers . Web3Provider ( provider ) const ethersProvider = new EthersEthereum ( new ethers . Wallet ( wallet . getPrivateKeyString (), ethersWeb3Provider )) const ethWallet = new EthereumWallet ( ethersProvider ) // Second parameter \u2014 is environment: \"prod\" | \"staging\" | \"e2e\" | \"dev\" const raribleSdk = createRaribleSdk ( ethWallet , \"staging\" ) Flow import * as fcl from \"@onflow/fcl\" import { FlowWallet } from \"@rarible/sdk-wallet\" const wallet = new FlowWallet ( fcl ) You also need to configure Flow Client Library (FCL), because Flow-sdk use @onflow/fcl-js : //example config for testnet import { config } from \"@onflow/fcl\" ; config ({ \"accessNode.api\" : \"https://access-testnet.onflow.org\" , // Mainnet: \"https://access-mainnet-beta.onflow.org\" \"discovery.wallet\" : \"https://fcl-discovery.onflow.org/testnet/authn\" // Mainnet: \"https://fcl-discovery.onflow.org/authn\" }) See more configuration details on Flow documentation . Tezos To initialize wallets, you can use: in_memory_provider (also for backend) beacon_provider (@rarible/tezos-sdk/dist/providers/beacon/beacon_provider) //in_memory_provider usage example import { in_memory_provider } from \"@rarible/tezos-sdk/dist/providers/in_memory/in_memory_provider\" import { TezosWallet } from \"@rarible/sdk-wallet\" const provider = in_memory_provider ( \"edsk...\" , nodeUrl ) const wallet = new TezosWallet ( provider )","title":"Initialize simple wallets"},{"location":"reference/wallets/#use-rarible-sdk-wallet-connector","text":"Wallet Connector make possible to connect the following providers: InjectedWeb3ConnectionProvider \u2014 Metamask, Coinbase, etc FortmaticConnectionProvider PortisConnectionProvider TorusConnectionProvider WalletLinkConnectionProvider MEWConnectionProvider IframeConnectionProvider WalletConnectConnectionProvider BeaconConnectionProvider FclConnectionProvider Read more about installation and using examples of Rarible SDK Wallet Connector.","title":"Use Rarible SDK Wallet Connector"},{"location":"snippets/preparation-sdk/","text":"Before start, install and configure Rarible SDK and required wallets .","title":"Preparation sdk"},{"location":"snippets/usage-sdk-ethers/","text":"// Imports import type Wallet from \"ethereumjs-wallet\" import Web3 from \"web3\" import { ethers } from \"ethers\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" import { EthersEthereum, EthersWeb3ProviderEthereum } from \"@rarible/ethers-ethereum\" // Code export function createProviders(provider: any, wallet: Wallet) { const web3 = new Web3(provider) const ethersWeb3Provider = new ethers.providers.Web3Provider(provider) return { web3, providers: [ new Web3Ethereum({ web3 }), new EthersEthereum(new ethers.Wallet(wallet.getPrivateKeyString(), ethersWeb3Provider)), new EthersWeb3ProviderEthereum(ethersWeb3Provider), ], } } const ethWallet = new EthereumWallet(ethersEthereumProviderInstance) const raribleSdk = createRaribleSdk(ethWallet, \"staging\")","title":"Usage sdk ethers"},{"location":"snippets/usage-sdk-on-server/","text":"Using SDK on server application \u00b6 The SDK was designed for use on the frontend side. To use the SDK on the server side (backend): Install packages: yarn add tslib@2.3.1 yarn add form-data yarn add node-fetch Add dependencies: global . FormData = require ( \"form-data\" ) global . window = { fetch : require ( \"node-fetch\" ), dispatchEvent : () => { }, } global . CustomEvent = function CustomEvent () { return } Try our example to buy Ethereum NFT item on Rinkeby network. Pass private key, node RPC URL, network ID, item ID for buyout and start: ETH_PRIVATE_KEY = \"0x...\" \\ ETHEREUM_RPC_URL = \"https://rinkeby.infura.io/...\" \\ ETHEREUM_NETWORK_ID = \"4\" \\ BUYOUT_ITEM_ID = \"0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7:102581254137174039089845694331937600507918590364933200920056519678660477714440\" \\ ts-node packages/sdk/example/backend/buy.ts","title":"Usage sdk on server"},{"location":"snippets/usage-sdk-on-server/#using-sdk-on-server-application","text":"The SDK was designed for use on the frontend side. To use the SDK on the server side (backend): Install packages: yarn add tslib@2.3.1 yarn add form-data yarn add node-fetch Add dependencies: global . FormData = require ( \"form-data\" ) global . window = { fetch : require ( \"node-fetch\" ), dispatchEvent : () => { }, } global . CustomEvent = function CustomEvent () { return } Try our example to buy Ethereum NFT item on Rinkeby network. Pass private key, node RPC URL, network ID, item ID for buyout and start: ETH_PRIVATE_KEY = \"0x...\" \\ ETHEREUM_RPC_URL = \"https://rinkeby.infura.io/...\" \\ ETHEREUM_NETWORK_ID = \"4\" \\ BUYOUT_ITEM_ID = \"0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7:102581254137174039089845694331937600507918590364933200920056519678660477714440\" \\ ts-node packages/sdk/example/backend/buy.ts","title":"Using SDK on server application"},{"location":"snippets/usage-sdk/","text":"// Imports import Web3 from \"web3\" import { createRaribleSdk } from \"@rarible/sdk\" import { EthereumWallet } from \"@rarible/sdk-wallet\" import { Blockchain } from \"@rarible/api-client\" import { Web3Ethereum } from \"@rarible/web3-ethereum\" // Code const { ethereum } = window as any const web3 = new Web3(provider) const web3Ethereum = new Web3Ethereum({ web3 }) const ethWallet = new EthereumWallet(web3Ethereum) const raribleSdk = createRaribleSdk(ethWallet, \"staging\")","title":"Usage sdk"},{"location":"use-cases/bubblesdk/","text":"Rarible SDK No-Code plugin for Bubble \u00b6 This plugin has been developed by EzCode . You can now use the Rarible Protocol SDK and build your own NFT Marketplace without deep knowledge on how to code. We have integrated the SDK in a no-code plugin for Bubble.io You can use the SDK without any programming skills and build your own NFT Marketplace entirely without code. We have integrated SDK into a no-code plugin for the biggest no-code platform Bubble.io . Link to the plugin Link to documentation Examples on using the plugin All examples are open source, you can see how it works from the inside. API supported features: \u00b6 Get Item Metadata Get Item Data Get Orders By Wallet Get Order By Hash Get NFT Ownership Get NFT Order Activities Get Order Activities By Item Get All NFT Items By Owner, Creator, Collection SDK supported features: \u00b6 ERC721 and ERC1155 supported Mint Lazy Mint (Buyer pays the fee) Custom Royalties Custom Origin Fees Create Order (Sell, Bid) Buy item Accept Bid Transfer an NFT to other wallet Cancel Order Burn For any plugin/bubble related questions we have a separate thread on Bubble\u2019s forum here . How to use: \u00b6 Instructions Place the element Rarible SDK on the page Make sure it is visible (not in a popup or a hidden group) Select the network in the plugin element field \"Environment\" Ready to go? We are working on documentation and more demo pages. NFT Marketplaces being built with this plugin: - one2all","title":"EZCode SDK plugin"},{"location":"use-cases/bubblesdk/#rarible-sdk-no-code-plugin-for-bubble","text":"This plugin has been developed by EzCode . You can now use the Rarible Protocol SDK and build your own NFT Marketplace without deep knowledge on how to code. We have integrated the SDK in a no-code plugin for Bubble.io You can use the SDK without any programming skills and build your own NFT Marketplace entirely without code. We have integrated SDK into a no-code plugin for the biggest no-code platform Bubble.io . Link to the plugin Link to documentation Examples on using the plugin All examples are open source, you can see how it works from the inside.","title":"Rarible SDK No-Code plugin for Bubble"},{"location":"use-cases/bubblesdk/#api-supported-features","text":"Get Item Metadata Get Item Data Get Orders By Wallet Get Order By Hash Get NFT Ownership Get NFT Order Activities Get Order Activities By Item Get All NFT Items By Owner, Creator, Collection","title":"API supported features:"},{"location":"use-cases/bubblesdk/#sdk-supported-features","text":"ERC721 and ERC1155 supported Mint Lazy Mint (Buyer pays the fee) Custom Royalties Custom Origin Fees Create Order (Sell, Bid) Buy item Accept Bid Transfer an NFT to other wallet Cancel Order Burn For any plugin/bubble related questions we have a separate thread on Bubble\u2019s forum here .","title":"SDK supported features:"},{"location":"use-cases/bubblesdk/#how-to-use","text":"Instructions Place the element Rarible SDK on the page Make sure it is visible (not in a popup or a hidden group) Select the network in the plugin element field \"Environment\" Ready to go? We are working on documentation and more demo pages. NFT Marketplaces being built with this plugin: - one2all","title":"How to use:"},{"location":"use-cases/coconft/","text":"cocoNFT \u00b6 TLDR: cocoNFT helps new creators get into the NFT space by building an onRamp that makes it easy to manage your wallet via social media logins. cocoNFT uses the following Smart Contract functionalities: lazy minting, exchange, and indexer. cocoNFT uses lazy minting so that the creators don't have to pay for minting making the process easy for newbies to crypto. They are planning on using the ability to support checkout right on our website via the Rarible Protocol Exchange and the indexer I believe to show a user's Lazy Minted NFTs. How cocoNFT would have changed things knowing what they know now: On the Protocol we developed code to handle many features that we needed Rarible Protocol to do. Instead of waiting for the protocol updates. As we were building found a lot of frameworks, we would have used something like starter app to jumpstart our development process. In regards to the database side cocoNFT advises understanding how you structure your database. Step by step instructions for teams to do the same: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so that you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder API and/or SDK is in the works for cocoNFT.","title":"cocoNFT"},{"location":"use-cases/coconft/#coconft","text":"TLDR: cocoNFT helps new creators get into the NFT space by building an onRamp that makes it easy to manage your wallet via social media logins. cocoNFT uses the following Smart Contract functionalities: lazy minting, exchange, and indexer. cocoNFT uses lazy minting so that the creators don't have to pay for minting making the process easy for newbies to crypto. They are planning on using the ability to support checkout right on our website via the Rarible Protocol Exchange and the indexer I believe to show a user's Lazy Minted NFTs. How cocoNFT would have changed things knowing what they know now: On the Protocol we developed code to handle many features that we needed Rarible Protocol to do. Instead of waiting for the protocol updates. As we were building found a lot of frameworks, we would have used something like starter app to jumpstart our development process. In regards to the database side cocoNFT advises understanding how you structure your database. Step by step instructions for teams to do the same: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so that you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder API and/or SDK is in the works for cocoNFT.","title":"cocoNFT"},{"location":"use-cases/mintgate/","text":"MintGate \u00b6 TLDR: MintGate decided to integrate Rarible protocol by building their marketplace on it to provide the best experience for their growing community of creators and influencers. The usages of the Rarible Protocol within MintGate are: Lazy Minting, Exchange, and Indexer We forked the 1155 contracts from Rarible to create a custom contract to mint from that has all the same functionality to abide by the royalties. We are using that contract and the exchange contracts + indexer that Rarible provides through the APIs. The steps for how we forked the contracts are listed below. From there we used the starter app and Eugene's sample project as templates for creating signed sale orders to submit to the exchange. We use the indexer to pull created sale order data for purchases and information display, which are all included in the Rarible APIs. How MintGate would have changed things knowing what they know now: One thing Mintgate would have done differently based on experience is to prioritize the Rarible marketplace order creation features sooner instead of focusing on lazy minting alone. Mintgate hopes Rarible will be able to complete an SDK alternative to the API's because they fail from time to time, which can cause confusion for users and bugs when there is no sale order or lazy mint created. Using a SDK would hopefully prove more reliable. Step by step instructions for how MintGate started building on Rarible protocol: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder APIs for MintGate for token gating are available. Full documentation and instructions can be found here: MintGate Docs","title":"MintGate"},{"location":"use-cases/mintgate/#mintgate","text":"TLDR: MintGate decided to integrate Rarible protocol by building their marketplace on it to provide the best experience for their growing community of creators and influencers. The usages of the Rarible Protocol within MintGate are: Lazy Minting, Exchange, and Indexer We forked the 1155 contracts from Rarible to create a custom contract to mint from that has all the same functionality to abide by the royalties. We are using that contract and the exchange contracts + indexer that Rarible provides through the APIs. The steps for how we forked the contracts are listed below. From there we used the starter app and Eugene's sample project as templates for creating signed sale orders to submit to the exchange. We use the indexer to pull created sale order data for purchases and information display, which are all included in the Rarible APIs. How MintGate would have changed things knowing what they know now: One thing Mintgate would have done differently based on experience is to prioritize the Rarible marketplace order creation features sooner instead of focusing on lazy minting alone. Mintgate hopes Rarible will be able to complete an SDK alternative to the API's because they fail from time to time, which can cause confusion for users and bugs when there is no sale order or lazy mint created. Using a SDK would hopefully prove more reliable. Step by step instructions for how MintGate started building on Rarible protocol: Always test on testnet before deploying to mainnet. Ropsten recommended for using Rarible APIs. Fork Rarible Protocol: https://github.com/rarible/protocol-contracts (Best to explore and get familiar) Identify which NFT token type you will be using, 721 or 1155, and make any modifications necessary in the tokens folder: https://github.com/rarible/protocol-contracts/tree/master/tokens Update the migrations files to pass in whatever parameters you want for the contract you plan to deploy: https://github.com/rarible/protocol-contracts/tree/master/tokens/migrations Note Only migration files 1-4 are necessary for initial deployment, and only #2 for 721 and #3 for 1155 if you don't want to deploy contracts for both. Take note of the addresses for the contracts. These are upgradeable contracts, so you will be directing calls to the proxy address. Test some functions like name() or symbol() in your terminal to ensure it's working Start using Rarible's APIs for lazy minting and order creation to build out your marketplace: https://api-reference.rarible.com/#operation/upsertOrder APIs for MintGate for token gating are available. Full documentation and instructions can be found here: MintGate Docs","title":"MintGate"},{"location":"use-cases/moralisplugin/","text":"Moralis Rarible Plugin \u00b6 This plugin has been developed by the Moralis team. For support, open a github issue Link to the plugin Link to documentation This plugin enables interaction with Rarible, allowing anyone to lazy-mint an NFT and sell it. Supported chains \u00b6 This plugins works with 2 different blockchains: Ethereum Mainnet (\u2018eth\u2019) Ethereum Rinkeby (\u2018rinkeby\u2019) Supported tokens \u00b6 ERC721 ERC1155 SDK \u00b6 Import the Moralis SDK in your project. < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"https://npmcdn.com/moralis@latest/dist/moralis.js\" ></ script > Lazy mint \u00b6 You can lazy mint a token by calling the lazyMint endpoint. This endpoint returns an object that contains the tokenId and tokenAddress of the lazy minted token. await Moralis . Plugins . rarible . lazyMint ({ chain : 'rinkeby' , userAddress : '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3' , tokenType : 'ERC1155' , tokenUri : '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp' , supply : 100 , royaltiesAmount : 5 , // 0.05% royalty. Optional }) You can also lazy mint a token and sell immediately. Below we are goin to lazy mint a token and create a sell order for it. In this example, we are selling 3 out of the 100 tokens created for 1 ETH (10 ** 18) each. await Moralis . Plugins . rarible . lazyMint ({ chain : 'rinkeby' , userAddress : '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3' , tokenType : 'ERC1155' , tokenUri : '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp' , supply : 100 , royaltiesAmount : 5 , // 0.05% royalty. Optional list : true , // Only if lazy listing listTokenAmount : 3 , // Only if lazy listing listTokenValue : 10 ** 18 , // Only if lazy listing listAssetClass : 'ETH' , // only if lazy listing || optional }) Sell order \u00b6 You can create a sell order for a lazy minted token by calling the createSellOrder endpoint. In this example, we are selling 4 tokens created for 1 ETH (10 ** 18) each. await Moralis . Plugins . rarible . createSellOrder ({ chain : 'rinkeby' , userAddress : '0xE78dC206875373B351EEF2D182025bb9a64d67B3' , makeTokenId : '104734732573670734795292663651146618103387426131809974624560761860320187646009' , makeTokenAddress : '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7' , makeAssetClass : 'ERC1155' , makeValue : '4' , takeAssetClass : 'ETH' , takeValue : 10 ** 18 , }); ERC20 \u00b6 You can sell a lazy minted token for ERC20 instead of ETH. Make sure to specify the following parameters: takeAssetClass : 'ERC20' , takeTokenAddress : '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea' , // DAI Example: await Moralis . Plugins . rarible . createSellOrder ({ chain : 'rinkeby' , userAddress : '0xE78dC206875373B351EEF2D182025bb9a64d67B3' , makeTokenId : '104734732573670734795292663651146618103387426131809974624560761860320187646009' , makeTokenAddress : '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7' , makeAssetClass : 'ERC1155' , makeValue : '4' , takeAssetClass : 'ERC20' , takeTokenAddress : '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea' , // DAI takeValue : 10 ** 18 , });","title":"Moralis Lazy Mint & Sell plugin"},{"location":"use-cases/moralisplugin/#moralis-rarible-plugin","text":"This plugin has been developed by the Moralis team. For support, open a github issue Link to the plugin Link to documentation This plugin enables interaction with Rarible, allowing anyone to lazy-mint an NFT and sell it.","title":"Moralis Rarible Plugin"},{"location":"use-cases/moralisplugin/#supported-chains","text":"This plugins works with 2 different blockchains: Ethereum Mainnet (\u2018eth\u2019) Ethereum Rinkeby (\u2018rinkeby\u2019)","title":"Supported chains"},{"location":"use-cases/moralisplugin/#supported-tokens","text":"ERC721 ERC1155","title":"Supported tokens"},{"location":"use-cases/moralisplugin/#sdk","text":"Import the Moralis SDK in your project. < script src = \"https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js\" ></ script > < script src = \"https://npmcdn.com/moralis@latest/dist/moralis.js\" ></ script >","title":"SDK"},{"location":"use-cases/moralisplugin/#lazy-mint","text":"You can lazy mint a token by calling the lazyMint endpoint. This endpoint returns an object that contains the tokenId and tokenAddress of the lazy minted token. await Moralis . Plugins . rarible . lazyMint ({ chain : 'rinkeby' , userAddress : '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3' , tokenType : 'ERC1155' , tokenUri : '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp' , supply : 100 , royaltiesAmount : 5 , // 0.05% royalty. Optional }) You can also lazy mint a token and sell immediately. Below we are goin to lazy mint a token and create a sell order for it. In this example, we are selling 3 out of the 100 tokens created for 1 ETH (10 ** 18) each. await Moralis . Plugins . rarible . lazyMint ({ chain : 'rinkeby' , userAddress : '0x7f64041298CC2C045FE5eb0e897ab7b5D4BdB4F3' , tokenType : 'ERC1155' , tokenUri : '/ipfs/QmWLsBu6nS4ovaHbGAXprD1qEssJu4r5taQfB74sCG51tp' , supply : 100 , royaltiesAmount : 5 , // 0.05% royalty. Optional list : true , // Only if lazy listing listTokenAmount : 3 , // Only if lazy listing listTokenValue : 10 ** 18 , // Only if lazy listing listAssetClass : 'ETH' , // only if lazy listing || optional })","title":"Lazy mint"},{"location":"use-cases/moralisplugin/#sell-order","text":"You can create a sell order for a lazy minted token by calling the createSellOrder endpoint. In this example, we are selling 4 tokens created for 1 ETH (10 ** 18) each. await Moralis . Plugins . rarible . createSellOrder ({ chain : 'rinkeby' , userAddress : '0xE78dC206875373B351EEF2D182025bb9a64d67B3' , makeTokenId : '104734732573670734795292663651146618103387426131809974624560761860320187646009' , makeTokenAddress : '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7' , makeAssetClass : 'ERC1155' , makeValue : '4' , takeAssetClass : 'ETH' , takeValue : 10 ** 18 , });","title":"Sell order"},{"location":"use-cases/moralisplugin/#erc20","text":"You can sell a lazy minted token for ERC20 instead of ETH. Make sure to specify the following parameters: takeAssetClass : 'ERC20' , takeTokenAddress : '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea' , // DAI Example: await Moralis . Plugins . rarible . createSellOrder ({ chain : 'rinkeby' , userAddress : '0xE78dC206875373B351EEF2D182025bb9a64d67B3' , makeTokenId : '104734732573670734795292663651146618103387426131809974624560761860320187646009' , makeTokenAddress : '0x1AF7A7555263F275433c6Bb0b8FdCD231F89B1D7' , makeAssetClass : 'ERC1155' , makeValue : '4' , takeAssetClass : 'ERC20' , takeTokenAddress : '0x5592ec0cfb4dbc12d3ab100b257153436a1f0fea' , // DAI takeValue : 10 ** 18 , });","title":"ERC20"},{"location":"use-cases/picnic/","text":"Picnic \u00b6 We use Rarible to help us identify NFTs from creators and collectors in the Picnic showcase. The Rarible API provides a few great endpoints for fetching the necessary data. API Calls \u00b6 The following endpoints can be used: Production(Mainnet, Chain ID: 1): https://ethereum-api.rarible.org Staging (Ropsten, Chain ID: 3): https://ethereum-api-dev.rarible.org Staging (Rinkeby, Chain ID:4): https://ethereum-api-staging.rarible.org Getting Tokens by Owner \u00b6 Paginate through owned tokens import axios from 'axios' ; /** * Get collector's owned tokens. * @param {string} owner - owner address (0x...) * @param {object} opts - options * @param {string} opts.continuation - Rariable continuation ID * @param {integer} opts.size - size of tokens to get (default: 100). * @return */ const fetchOwnedTokens = async ( owner , opts = {}) => { const { continuation , size = 100 } = opts ; try { const result = await axios . get ( 'https://api.rarible.com/protocol/v0.1/ethereum/nft/items/byOwner' , { params : { owner , continuation }, }); const { data } = result ; // Paginate results let hist = []; if ( data . continuation && data . items . length === size ) { hist = await getOwnedTokens ( owner , { ... opts , continuation : data.continuation }); } // Return full history return [... data . items , ... hist ]; } catch ( err ) { console . error ( err ); return []; } }; The byOwner endpoint does not return token metadata. You can attempt to query this information from the blockchain directly or use another API to collect token metadata information. You can use the getItemMetaById Rarible API endpoint to get token metadata. Be mindful that you\u2019ll have to make one request per token. import axios from 'axios' ; /** * Get token metadata from token id. * @param {string} id - token ID, formatted as CONTRACT_ADDRESS:TOKEN_ID (e.g. 0x1:1001) * @return {object} */ const fetchTokenMetadata = async id => { const { data } = await axios . get ( `https://api.rarible.com/protocol/v0.1/ethereum/nft/items/ ${ id } /meta` ); if ( ! data ? . name ) { throw new Error ( 'Invalid NFT data' , { id , data }); } return data ; }; If you have question, please reach out. greg@picnic.show / [@gleuch]","title":"Picnic"},{"location":"use-cases/picnic/#picnic","text":"We use Rarible to help us identify NFTs from creators and collectors in the Picnic showcase. The Rarible API provides a few great endpoints for fetching the necessary data.","title":"Picnic"},{"location":"use-cases/picnic/#api-calls","text":"The following endpoints can be used: Production(Mainnet, Chain ID: 1): https://ethereum-api.rarible.org Staging (Ropsten, Chain ID: 3): https://ethereum-api-dev.rarible.org Staging (Rinkeby, Chain ID:4): https://ethereum-api-staging.rarible.org","title":"API Calls"},{"location":"use-cases/picnic/#getting-tokens-by-owner","text":"Paginate through owned tokens import axios from 'axios' ; /** * Get collector's owned tokens. * @param {string} owner - owner address (0x...) * @param {object} opts - options * @param {string} opts.continuation - Rariable continuation ID * @param {integer} opts.size - size of tokens to get (default: 100). * @return */ const fetchOwnedTokens = async ( owner , opts = {}) => { const { continuation , size = 100 } = opts ; try { const result = await axios . get ( 'https://api.rarible.com/protocol/v0.1/ethereum/nft/items/byOwner' , { params : { owner , continuation }, }); const { data } = result ; // Paginate results let hist = []; if ( data . continuation && data . items . length === size ) { hist = await getOwnedTokens ( owner , { ... opts , continuation : data.continuation }); } // Return full history return [... data . items , ... hist ]; } catch ( err ) { console . error ( err ); return []; } }; The byOwner endpoint does not return token metadata. You can attempt to query this information from the blockchain directly or use another API to collect token metadata information. You can use the getItemMetaById Rarible API endpoint to get token metadata. Be mindful that you\u2019ll have to make one request per token. import axios from 'axios' ; /** * Get token metadata from token id. * @param {string} id - token ID, formatted as CONTRACT_ADDRESS:TOKEN_ID (e.g. 0x1:1001) * @return {object} */ const fetchTokenMetadata = async id => { const { data } = await axios . get ( `https://api.rarible.com/protocol/v0.1/ethereum/nft/items/ ${ id } /meta` ); if ( ! data ? . name ) { throw new Error ( 'Invalid NFT data' , { id , data }); } return data ; }; If you have question, please reach out. greg@picnic.show / [@gleuch]","title":"Getting Tokens by Owner"},{"location":"use-cases/use-cases-overview/","text":"Use Cases \u00b6 Picnic \u2014 use case with Rarible Protocol SDK and API cocoNFT and MintGate \u2014 use cases with Rarible Smart Contracts and API SDK plugin for Bubble \u2014 No-Code plugin for Bubble.io with Rarible Protocol SDK Moralis Plugin \u2014 plugin for Moralis.io that enables interaction with Rarible","title":"Overview"},{"location":"use-cases/use-cases-overview/#use-cases","text":"Picnic \u2014 use case with Rarible Protocol SDK and API cocoNFT and MintGate \u2014 use cases with Rarible Smart Contracts and API SDK plugin for Bubble \u2014 No-Code plugin for Bubble.io with Rarible Protocol SDK Moralis Plugin \u2014 plugin for Moralis.io that enables interaction with Rarible","title":"Use Cases"}]}